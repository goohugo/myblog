<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/goohugo/myblog</id><title>RSS feed of goohugo's myblog</title><updated>2025-01-03T08:43:38.203514+00:00</updated><author><name>goohugo</name><email>haoz0x139@gmail.com</email></author><link href="https://github.com/goohugo/myblog"/><link href="https://raw.githubusercontent.com/goohugo/myblog/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/goohugo/myblog/issues/41</id><title>GitHub连不上怎么办？</title><updated>2025-01-03T08:43:38.963609+00:00</updated><content type="html"><![CDATA[<p>（steam++）官方下载地址：<a href="https://steampp.net/">https://steampp.net/</a></p>
<p>github520开源仓库：<a href="https://github.com/521xueweihan/GitHub520">https://github.com/521xueweihan/GitHub520</a></p>
<p>Xbox下载加速器：<a href="https://github.com/skydevil88/XboxDownload">https://github.com/skydevil88/XboxDownload</a></p>
<p>一行命令上GitHub的仓库： <a href="https://github.com/feng2208/github-hosts">https://github.com/feng2208/github-hosts</a></p>
<p>微软edge浏览器使用命令（注意文件路径是否一致）：
&amp;&quot;C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe&quot; --host-rules=&quot;MAP github.com octocaptcha.com, MAP github.githubassets.com yelp.com, MAP *.githubusercontent.com githubusercontent.com&quot; --host-resolver-rules=&quot;MAP octocaptcha.com 20.27.177.113, MAP yelp.com 199.232.240.116, MAP githubusercontent.com 199.232.176.133&quot;</p>
<p>谷歌浏览器使用命令（注意文件路径是否一致）：
&amp;&quot;C:\Program Files\Google\Chrome\Application\chrome.exe&quot; --host-rules=&quot;MAP github.com octocaptcha.com, MAP github.githubassets.com yelp.com, MAP *.githubusercontent.com githubusercontent.com&quot; --host-resolver-rules=&quot;MAP octocaptcha.com 20.27.177.113, MAP yelp.com 199.232.240.116, MAP githubusercontent.com 199.232.176.133&quot;</p>
]]></content><link href="https://github.com/goohugo/myblog/issues/41"/><category term="Development"/><published>2024-12-17T03:30:52+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/40</id><title>System.Data.SqlClient could not be loaded解决办法</title><updated>2025-01-03T08:43:39.348357+00:00</updated><content type="html"><![CDATA[<h2>问题现象</h2>
<pre><code>The Entity Framework provider type &#x27;System.Data.Entity.SqlServer.SqlProviderServices, 
EntityFramework.SqlServer&#x27; registered in the application config file for the ADO.NET provider with invariant name
 &#x27;System.Data.SqlClient&#x27; could not be loaded. Make sure that the assembly-qualified name is used and that the 
assembly is available to the running application.
</code></pre>
<p>这是一个误导人的错误信息，实际是因为找不到 EntityFramework.SqlServer.dll 文件。
问题背景是web项目所引用的项目中安装了EF的nuget包，而web项目本身没有安装。于是build后，web项目的bin文件夹中只有EntityFramework.dll，却没有EntityFramework.SqlServer.dll。</p>
<h2>解决方案</h2>
<p>web项目也安装Entity Framework的nuget包。</p>
<blockquote>
<p>把所引用的项目中安装了EF的nuget包的bin目录下的EntityFramework.SqlServer.dll 文件复制到Web项目中的bin目录下</p>
</blockquote>
]]></content><link href="https://github.com/goohugo/myblog/issues/40"/><category term="Development"/><published>2024-12-13T03:08:26+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/39</id><title>比特币白皮书中文版</title><updated>2025-01-03T08:43:39.722640+00:00</updated><content type="html"><![CDATA[<h1>比特币：一种点对点的电子现金系统</h1>
<p>​								作者：中本聪
​								<a href="mailto:satoshin@gmx.com">satoshin@gmx.com</a>
​								<a href="http://www.bitcoin.org">www.bitcoin.org</a>
​								2008.10.31</p>
<p>​								中文翻译：李笑来
​								<a href="mailto:lixiaolai@gmail.com">lixiaolai@gmail.com</a>
​								2018.10.31</p>
<p>​								<a href="https://github.com/xiaolai/bitcoin-whitepaper-chinese-translation">Checkout Github Repo for this translation</a></p>
<blockquote>
<p><strong>Abstract.</strong> A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone. </p>
<p><strong>概要</strong>：一个纯粹的点对点版本的电子现金系统，将允许在线支付直接从一方发送到另一方，而无需通过金融机构。数字签名虽然提供了部分解决方案，但，若是仍然需要被信任的第三方来防止双重支出的话，那么电子支付的主要优势就被抵消了。我们提出一个方案，使用点对点网络去解决双重支出问题。点对点网络将为每笔交易标记时间戳，方法是：把交易的散列数据录入一个不断延展的、以散列为基础的工作证明链上，形成一个如非完全重做就不可能改变的记录。最长链，一方面用来证明已被见证的事件及其顺序，与此同时，也用来证明它来自于最大的 CPU 算力池。只要绝大多数 CPU 算力被良性节点控制 —— 即，它们不与那些尝试攻击网络的节点合作 —— 那么，良性节点将会生成最长链，并且在速度上超过攻击者。这个网络本身需要最小化的结构。信息将以最大努力为基本去传播，节点来去自由；但，加入之时总是需要接受最长的工作证明链作为它们未参与期间所发生之一切的证明。</p>
</blockquote>
<hr />
<h2>1. 简介 (Introduction)</h2>
<p>Commerce on the Internet has come to rely almost exclusively on financial institutions serving as trusted third parties to process electronic payments. While the system works well enough for most transactions, it still suffers from the inherent weaknesses of the trust based model. Completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes. The cost of mediation increases transaction costs, limiting the minimum practical transaction size and cutting off the possibility for small casual transactions, and there is a broader cost in the loss of ability to make non-reversible payments for non-reversible services. With the possibility of reversal, the need for trust spreads. Merchants must be wary of their customers, hassling them for more information than they would otherwise need. A certain percentage of fraud is accepted as unavoidable. These costs and payment uncertainties can be avoided in person by using physical currency, but no mechanism exists to make payments over a communications channel without a trusted party.</p>
<p>互联网商业几乎完全依赖金融机构作为可信第三方去处理电子支付。虽然针对大多数交易来说，这个系统还算不错，但，它仍然被基于信任的模型所固有的缺陷所拖累。完全不可逆转的交易实际上并不可能，因为金融机构不能避免仲裁争议。仲裁成本增加了交易成本，进而限制了最小可能交易的规模，且干脆阻止了很多小额支付交易。除此之外，还有更大的成本：系统无法为那些不可逆的服务提供不可逆的支付。逆转的可能性，造成了对于信任的需求无所不在。商家必须提防着他们的顾客，麻烦顾客提供若非如此（如若信任）就并不必要的更多信息。一定比例的欺诈，被认为是不可避免的。这些成本和支付不确定性，虽然在人与人之间直接使用物理货币支付的时候是可以避免的；但，没有任何一个机制能在双方在其中一方不被信任的情况下通过沟通渠道进行支付。</p>
<p>What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. Transactions that are computationally impractical to reverse would protect sellers from fraud, and routine escrow mechanisms could easily be implemented to protect buyers. In this paper, we propose a solution to the double-spending problem using a peer-to-peer distributed timestamp server to generate computational proof of the chronological order of transactions. The system is secure as long as honest nodes collectively control more CPU power than any cooperating group of attacker nodes.</p>
<p>我们真正需要的是一种基于加密证明而非基于信任的电子支付系统，允许任意双方在不需要信任第三方的情况下直接交易。算力保障的不可逆转交易能帮助卖家不被欺诈，而保护买家的日常担保机制也很容易实现。在本论文中，我们将提出一种针对双重支出的解决方案，使用点对点的、分布式的时间戳服务器去生成基于算力的证明，按照时间顺序记录每条交易。此系统是安全的，只要诚实节点总体上相对于相互合作的攻击者掌握更多的 CPU 算力。</p>
<h2>2. 交易 (Transactions)</h2>
<p>We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership.</p>
<p>我们将一枚电子硬币定义为一个数字签名链。一位所有者将一枚硬币交给另一个人的时候，要通过在这个数字签名链的末尾附加上以下数字签名：上一笔交易的哈希（hash，音译，亦翻译为“散列值”），以及新所有者的公钥。收款人可以通过验证签名去验证数字签名链的所属权。</p>
<p><img src="images/transactions.svg" alt="" /></p>
<p>The problem of course is the payee can't verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank.</p>
<p>这个路径的问题在于收款人无法验证曾经的所有者之中没有人双重支付过。常见的解决方案是引入一个可信的中心化权威方，或称“铸币厂”，让它去检查每一笔交易是否存在双重支付。每一次发生交易之后，硬币必须返回到铸币厂，铸币厂再发行一枚新的硬币。进而，只有铸币厂直接发行的硬币才是可信的、未被双重支付过的。这个解决方案的问题在于，整个货币系统的命运被拴在运营铸币厂的那个公司（就好像银行那样）身上，每一笔交易必须通过它。</p>
<p>We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we don't care about later attempts to double-spend. The only way to confirm the absence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which arrived first. To accomplish this without a trusted party, transactions must be publicly announced[^1], and we need a system for participants to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received.</p>
<p>我们需要一种方式，可以让收款人确认之前的所有者并没有在任何之前的交易上签名。就我们的目的而言，只有最早的交易是算数的，所以，我们并不关心其后的双重支付企图。确认一笔交易不存在的唯一方法是获悉所有的交易。在铸币厂模型之中，铸币厂已然知悉所有的交易，并且能够确认这些交易的顺序。为了能在没有“被信任的一方”参与的情况下完成以上任务，交易记录必须被公开宣布[^1]，进而我们需要一个系统能让参与者们认同它们所接收到的同一个唯一的交易历史。收款人需要证明在每笔交易发生之时，大多数节点能够认同它是第一个被接收的。</p>
<h2>3. 时间戳服务器 (Timestamp Server)</h2>
<p>The solution we propose begins with a timestamp server. A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash, such as in a newspaper or Usenet post[^2] [^3] [^4] [^5]. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it.</p>
<p>本解决方案起步于一种时间戳服务器。时间戳服务器是这样工作的：为一组（block）记录（items）的哈希打上时间戳，而后把哈希广播出去，就好像一份报纸所做的那样，或者像是在新闻组（Usenet）里的一个帖子那样[^2] [^3] [^4] [^5]。显然，时间戳能够证明那数据在那个时间点之前已然存在，否则那哈希也就无法生成。每个时间戳在其哈希中包含着之前的时间戳，因此构成了一个链；每一个新的时间戳被添加到之前的时间戳之后。</p>
<p><img src="images/timestamp-server.svg" alt="" /></p>
<h2>4. 工作证明 (Proof-of-Work)</h2>
<p>To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back's Hashcash[^6], rather than newspaper or Usenet posts. The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash.</p>
<p>为了实现一个基于点对点的分布式时间戳服务器，我们需要使用类似亚当·伯克的哈希现金[^6]那样的一个工作证明系统，而不是报纸或者新闻组帖子那样的东西。所谓的工作证明，就是去寻找一个数值；这个数值要满足以下条件：为它提取散列数值之后 —— 例如使用 SHA-256 计算散列数值 —— 这个散列数值必须以一定数量的 0 开头。每增加一个 0 的要求，将使得工作量指数级增加，并且，这个工作量的验证却只需通过计算一个哈希。</p>
<p>For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block's hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it.</p>
<p>在我们的时间戳网络中，我们是这样实现工作证明的：不断在区块之中增加一个随机数（Nonce），直到一个满足条件的数值被找到；这个条件就是，这个区块的哈希以指定数量的 0 开头。一旦 CPU 的耗费算力所获的的结果满足工作证明，那么这个区块将不再能被更改，除非重新完成之前的所有工作量。随着新的区块不断被添加进来，改变当前区块即意味着说要重新完成所有其后区块的工作。</p>
<p><img src="images/proof-of-work.svg" alt="" /></p>
<p>The proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added.</p>
<p>工作证明同时解决了如何决定谁能代表大多数做决定的问题。如果所谓的“大多数”是基于“一个IP地址一票”的方式决定的话，那么任何一个可以搞定很多 IP 地址的人就可以被认为是“大多数”。工作证明本质上来看，是“一个CPU一票”。所谓的“大多数决定”是由最长链所代表的，因为被投入最多工作的链就是它。如果大多数 CPU 算力被诚实的节点所控制，那么诚实链成长最为迅速，其速度会远超其他竞争链。为了更改一个已经产生的区块，攻击者将不得不重新完成那个区块以及所有其后区块的的工作证明，而后还要追上并超过诚实节点的工作。后文展示为什么一个被拖延了的攻击者能够追上的可能性将随着区块的不断增加而指数级降低。</p>
<p>To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they're generated too fast, the difficulty increases.</p>
<p>为了应对硬件算力综合的不断增加，以及随着时间推进可能产生的节点参与数量变化，工作证明难度由此决定：基于平均每小时产生的区块数量的一个移动平均值。如果区块生成得过快，那么难度将会增加。</p>
<h2>5. 网络 (Network)</h2>
<p>The steps to run the network are as follows:</p>
<blockquote>
<ol>
<li>New transactions are broadcast to all nodes.</li>
<li>Each node collects new transactions into a block.</li>
<li>Each node works on finding a difficult proof-of-work for its block.</li>
<li>When a node finds a proof-of-work, it broadcasts the block to all nodes.</li>
<li>Nodes accept the block only if all transactions in it are valid and not already spent.</li>
<li>Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash.</li>
</ol>
</blockquote>
<p>运行网络的步骤如下：</p>
<blockquote>
<ol>
<li>所有新的交易向所有节点广播；</li>
<li>每个节点将新交易打包到一个区块；</li>
<li>每个节点开始为此区块找一个具备难度的工作证明；</li>
<li>当某个区块找到其工作证明，它就要将此区块广播给所有节点；</li>
<li>众多其他节点当且只当以下条件满足才会接受这个区块：其中所有的交易都是有效的，且未被双重支付；</li>
<li>众多节点向网络表示自己接受这个区块的方法是，在创建下一个区块的时候，把被接受区块的哈希当作新区块之前的哈希。</li>
</ol>
</blockquote>
<p>Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proof-of-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one.</p>
<p>节点始终认为最长链是正确的那个，且会不断向其添加新数据。若是有两个节点同时向网络广播了两个不同版本的“下一个区块”，有些节点会先接收到其中一个，而另外一些节点会先接收到另外一个。这种情况下，节点将在它们先接收到的那个区块上继续工作，但也会把另外一个分支保存下来，以防后者成为最长链。当下一个工作证明被找到，而其中的一个分支成为更长的链之后，这个暂时的分歧会被打消，在另外一个分支上工作的节点们会切换到更长的链上。</p>
<p>New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one.</p>
<p>新的交易不见得一定要广播到达所有的节点。只要到达足够多的节点，那么没多久这些交易就会被打包进一个区块。区块广播也容许一些消息被丢弃。如果一个节点并未接收到某个区块，那么这个节点会在它接收到下一个区块的时候意识到自己错失了之前的区块，因此会发出补充那个遗失区块的请求。</p>
<h2>6. 奖励 (Incentive)</h2>
<p>By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block. This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation, since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation. In our case, it is CPU time and electricity that is expended.</p>
<p>按照约定，每个区块的第一笔交易是一个特殊的交易，它会生成一枚新的硬币，所属权是这个区块的生成者。这么做，使得节点支持网络有所奖励，也提供了一种将硬币发行到流通之中的方式 —— 在这个系统中，反正也没有一个中心化的权威方去发行那些硬币。如此这般稳定地增加一定数量的新硬币进入流通，就好像是黄金开采者不断耗用他们的资源往流通之中增加黄金一样。在我们的系统中，被耗用的资源是 CPU 工作时间和它们所用的电力。</p>
<p>The incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free.</p>
<p>奖励还可以来自交易费用。如果一笔交易的输出值小于它的输入值，那么其中的差额就是交易费；而该交易费就是用来奖励节点把该交易打包进此区块的。一旦既定数量的硬币已经进入流通，那么奖励将全面交由交易手续费来完成，且绝对不会有通货膨胀。</p>
<p>The incentive may help encourage nodes to stay honest. If a greedy attacker is able to assemble more CPU power than all the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to generate new coins. He ought to find it more profitable to play by the rules, such rules that favour him with more new coins than everyone else combined, than to undermine the system and the validity of his own wealth.</p>
<p>奖励机制也可能会鼓励节点保持诚实。如果一个贪婪的攻击者能够网罗比所有诚实节点都更多的 CPU 算力，他必须做出一个选择：是用这些算力通过把自己花出去的钱偷回来去欺骗别人呢？还是用这些算力去生成新的硬币？他应该能够发现按照规则行事是更划算的，当前规则使得他能够获得比所有其他人加起来都更多的硬币，这显然比暗中摧毁系统并使自己的财富化为虚无更划算。</p>
<h2>7. 回收硬盘空间 (Reclaiming Disk Space)</h2>
<p>Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block's hash, transactions are hashed in a Merkle Tree[^2][^5][^7], with only the root included in the block's hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored.</p>
<p>如果一枚硬币最近发生的交易发生在足够多的区块之前，那么，这笔交易之前该硬币的花销交易记录可以被丢弃 —— 目的是为了节省磁盘空间。为了在不破坏该区块的哈希的前提下实现此功能，交易记录的哈希将被纳入一个 Merkle 树[^2][^5][^7]之中，而只有树根被纳入该区块的哈希之中。通过砍掉树枝方法，老区块即可被压缩。内部的哈希并不需要被保存。</p>
<p><img src="images/reclaiming-disk-space.svg" alt="" /></p>
<p>A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory.</p>
<p>一个没有任何交易记录的区块头大约是 80 个字节。假设每十分钟产生一个区块，80 字节乘以 6 乘以 24 乘以 365，等于每年 4.2M。截止 2008 年，大多数在售的计算机配有 2GB 内存，而按照摩尔定律的预测，每年会增加 1.2 GB，即便是区块头必须存储在内存之中也不会是什么问题。</p>
<h2>8. 简化版支付确认 (Simplified Payment Verification)</h2>
<p>It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it.</p>
<p>即便不用运行一个完整网络节点也有可能确认支付。用户只需要有一份拥有工作证明的最长链的区块头拷贝 —— 他可以通过查询在线节点确认自己拥有的确实来自最长链 —— 而后获取 Merkle 树的树枝节点，进而连接到这个区块被打上时间戳时的交易。用户并不能自己检查交易，但，通过连接到链上的某个地方，他可以看到某个网络节点已经接受了这个交易，而此后加进来的区块进一步确认了网络已经接受了此笔交易。</p>
<p><img src="images/simplified-payment-verification.svg" alt="" /></p>
<p>As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker's fabricated transactions for as long as the attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user's software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification.</p>
<p>只要诚实节点依然在掌控网络，如此这般，验证即为可靠的。然而，如果网络被攻击者所控制的时候，验证就没那么可靠了。尽管网络节点可以自己验证交易记录，但是，只要攻击者能够继续控制网络的话，那么简化版验证方式可能会被攻击者伪造的交易记录所欺骗。应对策略之一是，客户端软件要接受来自网络节点的警告。当网络节点发现无效区块的时候，即发出警报，在用户的软件上弹出通知，告知用户下载完整区块，警告用户确认交易一致性。那些有高频收付发生的商家应该仍然希望运行属于自己的完整节点，以此保证更独立的安全性和更快的交易确认。</p>
<h2>9. 价值的组合与分割 (Combining and Splitting Value)</h2>
<p>Although it would be possible to handle coins individually, it would be unwieldy to make a separate transaction for every cent in a transfer. To allow value to be split and combined, transactions contain multiple inputs and outputs. Normally there will be either a single input from a larger previous transaction or multiple inputs combining smaller amounts, and at most two outputs: one for the payment, and one returning the change, if any, back to the sender.</p>
<p>尽管逐个地处理硬币是可能的，但为每分钱设置一个单独的记录是很笨拙的。为了允许价值的分割与合并，交易记录包含多个输入和输出。一般情况下，要么是一个单独的来自于一个相对大的之前的交易的输入，要么是很多个输入来自于更小金额的组合；与此同时，最多有两个输出：一个是支付（指向收款方），如果必要的话，另外一个是找零（指向发款方）。</p>
<p><img src="images/combining-splitting-value.svg" alt="" /></p>
<p>It should be noted that fan-out, where a transaction depends on several transactions, and those transactions depend on many more, is not a problem here. There is never the need to extract a complete standalone copy of a transaction's history.</p>
<p>值得注意的是，“扇出”在这里并不是问题 —— 所谓“扇出”，就是指一笔交易依赖于数笔交易，且这些交易又依赖于更多笔交易。从来就没有必要去提取任何一笔交易的完整独立的历史拷贝。</p>
<h2>10. 隐私 (Privacy)</h2>
<p>The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party. The necessity to announce all transactions publicly precludes this method, but privacy can still be maintained by breaking the flow of information in another place: by keeping public keys anonymous. The public can see that someone is sending an amount to someone else, but without information linking the transaction to anyone. This is similar to the level of information released by stock exchanges, where the time and size of individual trades, the &quot;tape&quot;, is made public, but without telling who the parties were.</p>
<p>传统的银行模型通过限制他人获取交易者和可信第三方的信息而达成一定程度的隐私保护。出于对将所有交易记录公开的需求否决了这种方法。但是，维持隐私可通过于另一处的切断信息流来实现——公钥匿名。公众可以看到某某向某某转账了一定的金额，但是，没有任何信息指向某个确定的人。这种水平的信息发布有点像股市交易，只有时间和各个交易的金额被公布，但是，没有人知道交易双方都是谁。</p>
<p><img src="images/privacy.svg" alt="" /></p>
<p>As an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner. Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner. The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner.</p>
<p>还有另外一层防火墙。交易者应该针对每一笔交易启用一对新的公私钥，以便他人无法将这些交易追溯到同一个所有者身上。有些多输入的交易依然难免被追溯，因为那些输入必然会被识别出来自于同一个所有者。危险在于，如果一个公钥的所有者被曝光之后，与之相关的所有其他交易都会被曝光。</p>
<h2>11. 计算 (Calculations)</h2>
<p>We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent.</p>
<p>假设一个场景，某个攻击者正在试图生成一个比诚实链更快的替代链。就算他成功了，也不能对系统做任意的修改，即，他不可能凭空制造出价值，也无法获取从未属于他的钱。网络节点不会把一笔无效交易当作支付，而诚实节点也永远不会接受一个包含这种支付的区块。攻击者最多只能修改属于他自己的交易，进而试图取回他已经花出去的钱。</p>
<p>The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker's chain being extended by one block, reducing the gap by -1.</p>
<p>诚实链和攻击者之间的竞争可以用二项式随机漫步来描述。成功事件是诚实链刚刚被添加了一个新的区块，使得它的优势增加了 $1$；而失败事件是攻击者的链刚刚被增加了一个新的区块，使得诚实链的优势减少了 $1$。</p>
<p>The probability of an attacker catching up from a given deficit is analogous to a Gambler's Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows[^8]:</p>
<p>攻击者能够从落后局面追平的概率类似于赌徒破产问题。假设，一个拿着无限筹码的赌徒，从亏空开始，允许他赌无限次，目标是填补上已有的亏空。我们能算出他最终能填补亏空的概率，也就是攻击者能够赶上诚实链的概率[^8]，如下：</p>
<p>$$
\begin{eqnarray*}
\large p &amp;=&amp; \text{ 诚实节点找到下一个区块的概率}\
\large q &amp;=&amp; \text{ 攻击者找到下一个区块的概率}\
\large q_z &amp;=&amp; \text{ 攻击者落后 $z$ 个区块却依然能够赶上的概率}
\end{eqnarray*}
$$</p>
<p>$$
\large q_z = \begin{Bmatrix}
1 &amp; \textit{if}; p \leq q\
(q/p)^z &amp; \textit{if}; p &gt; q
\end{Bmatrix}
$$</p>
<p>Given our assumption that $p \gt q​$, the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn't make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind.</p>
<p>既然我们已经假定 $p &gt; q$, 既然攻击者需要赶超的区块数量越来越多，那么其成功概率就会指数级下降。于赢面不利时，如果攻击者没有在起初就能幸运地向前猛跨一步，那么他的胜率将在他进一步落后的同时消弭殆尽。</p>
<p>We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can't change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late.</p>
<p>现在考虑一下一笔新交易的收款人需要等多久才能充分确定发款人不能更改这笔交易。我们假定发款人是个攻击者，妄图让收款人在一段时间里相信他已经支付对付款项，随后将这笔钱再转回给自己。发生这种情况时，收款人当然会收到警告，但发款人希望那时木已成舟。</p>
<p>The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction.</p>
<p>收款人生成了一对新的公私钥，而后在签署之前不久将公钥告知发款人。这样可以防止一种情形：发款人提前通过连续运算去准备一条链上的区块，并且只要有足够的运气就会足够领先，直到那时再执行交易。一旦款项已被发出，那个不诚实的发款人开始秘密地在另一条平行链上开工，试图在其中加入一个反向版本的交易。</p>
<p>The recipient waits until the transaction has been added to a block and $z$ blocks have been linked after it. He doesn't know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution with expected value:</p>
<p>收款人等到此笔交易被打包进区块，并已经有 $z$ 个区块随后被加入。他并不知道攻击者的工作进展究竟如何，但是可以假定诚实区块在每个区块生成过程中耗费的平均时间；攻击者的潜在进展符合泊松分布，其期望值为：</p>
<p>$$
\large \lambda = z \frac qp
$$</p>
<p>To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point:</p>
<p>为了算出攻击者依然可以赶上的概率，我们要把攻击者需要追赶的区块数目的帕松分布概率密度，乘以在落后该区块数目下能够追上来的概率：</p>
<p>$$
\large \sum_{k=0}^{\infty} \frac{\lambda^k e^{-\lambda}}{k!} \cdot
\begin{Bmatrix}
(q/p)^{(z-k)} &amp; \textit{if};k\leq z\
1 &amp; \textit{if} ; k &gt; z
\end{Bmatrix}
$$</p>
<p>Rearranging to avoid summing the infinite tail of the distribution...</p>
<p>为了避免对密度分布的无穷级数求和重新整理…</p>
<p>$$
\large 1 - \sum_{k=0}^{z} \frac{\lambda^k e^{-\lambda}}{k!}
\left ( 1-(q/p)^{(z-k)} \right )
$$</p>
<p>Converting to C code...</p>
<p>转换为 C 语言程序……</p>
<pre><code class="language-c">#include &lt;math.h&gt;
double AttackerSuccessProbability(double q, int z)
{
	double p = 1.0 - q;
	double lambda = z * (q / p);
	double sum = 1.0;
	int i, k;
	for (k = 0; k &lt;= z; k++)
	{
		double poisson = exp(-lambda);
		for (i = 1; i &lt;= k; i++)
			poisson *= lambda / i;
		sum -= poisson * (1 - pow(q / p, z - k));
	}
	return sum;
}
</code></pre>
<p>Running some results, we can see the probability drop off exponentially with $z$.</p>
<p>获取部分结果，我们可以看到概率随着 $z$ 的增加指数级下降：</p>
<pre><code>   q=0.1
   z=0    P=1.0000000
   z=1    P=0.2045873
   z=2    P=0.0509779
   z=3    P=0.0131722
   z=4    P=0.0034552
   z=5    P=0.0009137
   z=6    P=0.0002428
   z=7    P=0.0000647
   z=8    P=0.0000173
   z=9    P=0.0000046
   z=10   P=0.0000012
   
   q=0.3
   z=0    P=1.0000000
   z=5    P=0.1773523
   z=10   P=0.0416605
   z=15   P=0.0101008
   z=20   P=0.0024804
   z=25   P=0.0006132
   z=30   P=0.0001522
   z=35   P=0.0000379
   z=40   P=0.0000095
   z=45   P=0.0000024
   z=50   P=0.0000006
</code></pre>
<p>Solving for P less than 0.1%...</p>
<p>若是 P 小于 0.1%……</p>
<pre><code>   P &lt; 0.001
   q=0.10   z=5
   q=0.15   z=8
   q=0.20   z=11
   q=0.25   z=15
   q=0.30   z=24
   q=0.35   z=41
   q=0.40   z=89
   q=0.45   z=340
</code></pre>
<h2>12. 结论 (Conclusion)</h2>
<p>We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism.</p>
<p>我们提出了一个不必依赖信任的电子交易系统；起点是一个普通的使用数字签名的硬币框架开始，虽然它提供了健壮的所有权控制，却无法避免双重支付。为了解决这个问题，我们提出一个使用工作证明机制的点对点网络去记录一个公开的交易记录历史，只要诚实节点能够控制大多数 CPU 算力，那么攻击者就仅从算力方面就不可能成功篡改系统。这个网络的健壮在于它的无结构的简单。节点们可以在很少协同的情况下瞬间同时工作。它们甚至不需要被辨认，因为消息的路径并非取决于特定的终点；消息只需要被以最大努力为基本去传播即可。节点来去自由，重新加入时，只需要接受工作证明链，作为它们离线之时所发生之一切的证明。它们通过它们的 CPU 算力投票，通过不断为链添加新的有效区块、拒绝无效区块，去表示它们对有效交易的接受与否。任何必要的规则和奖励都可以通过这个共识机制来强制实施。</p>
<hr />
<h2>参考文献 (References)</h2>
<p>[^1]: <strong>b-money</strong> Dai Wei (1998-11-01) <a href="http://www.weidai.com/bmoney.txt">http://www.weidai.com/bmoney.txt</a>
[^2]: <strong>Design of a secure timestamping service with minimal trust requirements</strong> Henri Massias, Xavier Serret-Avila, Jean-Jacques Quisquater <em>20th Symposium on Information Theory in the Benelux</em> (1999-05) <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.6228">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.6228</a>
[^3]: <strong>How to time-stamp a digital document</strong> Stuart Haber, W.Scott Stornetta <em>Journal of Cryptology</em> (1991) <a href="https://doi.org/cwwxd4">https://doi.org/cwwxd4</a> DOI: <a href="https://doi.org/10.1007/bf00196791">10.1007/bf00196791</a>
[^4]: <strong>Improving the Efficiency and Reliability of Digital Time-Stamping</strong> Dave Bayer, Stuart Haber, W. Scott Stornetta <em>Sequences II</em> (1993) <a href="https://doi.org/bn4rpx">https://doi.org/bn4rpx</a> DOI: <a href="https://doi.org/10.1007/978-1-4613-9323-8_24">10.1007/978-1-4613-9323-8_24</a>
[^5]: <strong>Secure names for bit-strings</strong> Stuart Haber, W. Scott Stornetta <em>Proceedings of the 4th ACM conference on Computer and communications security - CCS ’97</em>(1997) <a href="https://doi.org/dtnrf6">https://doi.org/dtnrf6</a> DOI: <a href="https://doi.org/10.1145/266420.266430">10.1145/266420.266430</a>
[^6]: <strong>Hashcash - A Denial of Service Counter-Measure</strong> Adam Back (2002-08-01) <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.8">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.8</a>
[^7]: <strong>Protocols for Public Key Cryptosystems</strong> Ralph C. Merkle <em>1980 IEEE Symposium on Security and Privacy</em> (1980-04) <a href="https://doi.org/bmvbd6">https://doi.org/bmvbd6</a> DOI: <a href="https://doi.org/10.1109/sp.1980.10006">10.1109/sp.1980.10006</a>
[^8]: <strong>An Introduction to Probability Theory and its Applications</strong> William Feller <em>John Wiley &amp; Sons</em> (1957) <a href="https://archive.org/details/AnIntroductionToProbabilityTheoryAndItsApplicationsVolume1">https://archive.org/details/AnIntroductionToProbabilityTheoryAndItsApplicationsVolume1</a></p>
]]></content><link href="https://github.com/goohugo/myblog/issues/39"/><category term="Technical Articles"/><published>2024-11-05T00:52:25+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/38</id><title>Win11 右键菜单优化代码</title><updated>2025-01-03T08:43:40.074290+00:00</updated><content type="html"><![CDATA[<p>回退经典右键菜单代码</p>
<pre><code>reg add &quot;HKCU\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32&quot; /f /ve
taskkill /f /im explorer.exe &amp; start explorer.exe
</code></pre>
<p>恢复win11新版右键菜单代码</p>
<pre><code>reg delete &quot;HKCU\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}&quot; /f
taskkill /f /im explorer.exe &amp; start explorer.exe
</code></pre>
]]></content><link href="https://github.com/goohugo/myblog/issues/38"/><category term="Technical Articles"/><published>2024-09-24T07:14:31+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/36</id><title>成为一名优秀开发者的10种方法</title><updated>2025-01-03T08:43:40.426308+00:00</updated><content type="html"><![CDATA[<p><img src="https://github.com/goohugo/myblog/assets/124132611/506eecac-b1bb-4f83-aaf2-7b4a1c46f8e7" alt="10-ways-to-be-a-better-developer)" /></p>
<ul>
<li>阅读别人的代码</li>
<li>让别人阅读你的代码</li>
<li>在写新代码之前修复现有代码中的错误</li>
<li>学习一种新技术</li>
<li>保持简单</li>
<li>写一篇关于你的代码的博客文章</li>
<li>贡献给开源项目</li>
<li>修复它，不要破坏它</li>
<li>提升代码覆盖率1%</li>
<li>每小时离开办公桌休息一下</li>
</ul>
<p>这些建议都是为了帮助开发者提高他们的技能和工作效率</p>
]]></content><link href="https://github.com/goohugo/myblog/issues/36"/><category term="Development"/><published>2024-06-26T07:27:16+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/35</id><title>Code Review Best Practices 读书笔记</title><updated>2025-01-03T08:43:40.781002+00:00</updated><content type="html"><![CDATA[<p>Kevin London在其文章<a href="https://www.kevinlondon.com/2015/05/05/code-review-best-practices">《Code Review Best Practices》</a>中分享了进行代码审查的最佳实践，这些实践适用于软件开发团队，旨在提高代码质量和团队协作。
以下是文章中的主要观点：</p>
<ul>
<li>职责单一原则（Single Responsibility Principle）: 一个类或方法应该只负责一项功能。如果描述一个方法的功能需要使用“并且”，这可能意味着方法的职责范围过广，应该考虑分解。</li>
<li>开放封闭原则（Open/Closed Principle）: 如果使用面向对象编程，确保对象易于扩展但不易修改。当需要增加新特性时，代码应该可以通过添加新代码来实现，而不是修改已有代码。</li>
<li>代码重复（Code Duplication）: 采用“三次触碰”规则。如果代码被复制了一次，通常可以容忍，但如果再次复制，应该重构代码，将重复的逻辑抽象出来。</li>
<li>眯眼测试（Squint Test）: 检查代码的布局和结构是否一致，是否存在可能指示代码结构问题的模式。</li>
<li>留下更好的代码（Code Left in a Better State）: 当修改混乱的代码区域时，应该努力让代码比原来更好。</li>
<li>潜在的bug: 检查是否有可能的off-by-one错误，循环是否能按照预期终止，以及是否会无限循环。</li>
<li>错误处理: 错误是否被优雅地处理，必要时是否明确地处理，是否添加了自定义错误，这些错误是否有用。</li>
<li>效率: 算法是否使用了高效的实现，例如，遍历字典的键列表来查找一个值是低效的。</li>
<li>命名规范: 方法和变量的命名是否准确反映了其功能，避免使用模糊或不具描述性的名称。</li>
<li>函数长度: 函数长度是否适中，避免过长的函数，以提高代码的可读性和维护性。</li>
<li>代码审查前的自我检查: 在提交代码审查前，作者应该先自我检查，如检查是否有遗留的注释或TODO标记，变量命名是否合理，以及其他在上述列出的事项。</li>
<li>人性化沟通: 代码审查不仅仅是技术评估，还涉及到人际交流。建议的方法包括提问、表扬、面对面讨论复杂点、解释建议的理由、聚焦于代码而非个人、区分建议的优先级等。</li>
<li>保持开放心态: 在代码审查中保持开放和非防御性的态度，理解审查的目的在于改进代码质量，而不是个人批评。
通过遵循这些最佳实践，软件团队可以提升代码的质量、可维护性和团队协作效率。</li>
</ul>
]]></content><link href="https://github.com/goohugo/myblog/issues/35"/><category term="Development"/><published>2024-06-26T07:19:57+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/32</id><title>使用存储过程非常慢，但是执行SQL很快的解决方案</title><updated>2025-01-03T08:43:41.159021+00:00</updated><content type="html"><![CDATA[<h1>前言</h1>
<p>最近，在工作中发现，两个问题:</p>
<ol>
<li>应用程序调用存储过程很慢，但是在查询分析器中把SQL语句拿出来执行存储过程就很快。</li>
<li>在查询分析器中执行存储过程很慢，但是把存储过程中的内容拿出来执行很快</li>
</ol>
<h1>问题的分析与解决</h1>
<h2>问题1 产生原因</h2>
<p>在应用程序中(或者在查询分析器中)调用存储过程的时候，存储过程的执行计划是被缓存了，就算参数不同，还是按照老的执行计划查询，效率也会不同。</p>
<h2>问题1 解决方法</h2>
<p>直接在存储过程定义参数的最后，添加<strong>WITH RECOMPILE</strong> 就会被强行重新编译执行存储过程</p>
<p>如下图代码所示：</p>
<pre><code>ALTER PROCEDURE PRO_NAME
(
   @PARA1 VARCHAR(100)
) WITH  RECOMPILE
</code></pre>
<h2>问题2 产生原因</h2>
<p>在执行存储过程中出现了参数嗅探</p>
<h2>问题2 解决方法</h2>
<p>如果存储过程调用的比较频繁可使用<strong>OPTION (OPTIMIZE FOR UNKNOWN)</strong>，如果不是，可使用<strong>OPTION (RECOMPILE)</strong>。</p>
<p>因为业务需要，存储过程需要频繁使用，所以，使用了<strong>OPTION (OPTIMIZE FOR UNKNOWN)</strong> 处理。</p>
<p>具体使用代码示例如下：</p>
<pre><code>ALTER PROCEDURE PRO_NAME
(
   @PARA1 VARCHAR(100)
) WITH  RECOMPILE
AS
BEGIN
   SELECT * FROM TABLE_NAME WHERE FIELD_NAME=@PARA1 OPTION (OPTIMIZE FOR UNKNOWN)
END
</code></pre>
<p>以上，亲测有效~</p>
]]></content><link href="https://github.com/goohugo/myblog/issues/32"/><category term="Technical Articles"/><published>2024-02-28T00:51:07+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/31</id><title>《繁花》爆火，这35句台词炸裂了</title><updated>2025-01-03T08:43:41.516183+00:00</updated><content type="html"><![CDATA[<p>01.大暑之后必要大寒。一定记住，这是规律。</p>
<p>02.外行看门面，内行看后门。</p>
<p>03.你以为吃的是龙虾，实际上吃的是机会，一只龙虾就是一个机会。不是在应酬，就是在求人。</p>
<p>04.凡事，总要留一手。</p>
<p>05.纽约的帝国大厦晓得吧？从底下跑到屋顶，要一个钟头，从屋顶跳下来，只要八点八秒，这就是股票。想从股票上赚钱，先学会输。</p>
<p>06.上海人做生意，讲究派头、噱头、苗头。这点行头，都是你的派头。这间包房就是你的噱头，人家开的是皮包公司，你也一样。不过你的皮包比别人大——和平饭店。</p>
<p>07.一个男人应该有多少个钱包？三只。第一只就是你实际有多少钱。第二只就是你的信用，人家钱包里的钞票你可以调动多少。第三只就是人家认为你有多少钱。《繁花》中爷叔的这段话，预示着一个人财富的三个层面：他的实际财富，他的信用，以及别人眼中他的财富。派头到位，彰显了第一只钱包；噱头是否到位，会影响第三只钱包；而苗头则会影响他的第二只钱包。</p>
<p>08.市场永远是对的，错的只有自己。冲得太快，逃得太慢，肯定是要吃瘪。头顶在肩膀上，脚长在自己身上，只要保护好自己，机会永远比风险大。</p>
<p>09.做生意不是比谁赚得多，要看谁活得长，不要想着一步登天，要一步一个脚印，稳扎稳打。</p>
<p>10.做生意，首先要学会两个字：不响。不知道的，说不清楚的，没想好、没规划的，为难自己、为难别人的，都不响。做事情要留有余地，对吧。“不响”在《繁花》原著中出现了上千次。在上海话中，表示不便说、不发声、不回答等丰富的含义，蕴含着千言万语、余味悠长的意境。”不响”不代表沉默，它是一种留白。</p>
<p>11.外贸就是借人家的鸡，生你自己的蛋，不过人家凭什么要把鸡借给你，帮你生蛋呢？</p>
<p>12.现在讲究市场经济，搞市场就相信市场，是一块钱吃一杯茶，还是十块钱吃一杯茶，是人家的事情。不相信市场就像我们一样，太太平平过日子。这是剧中人物景秀的台词。景秀是一个小卖部的小老板，与做大生意的阿宝、爷叔、李李相比，他是黄河路中普通人的缩影，是时代的小人物。</p>
<p>13.资本市场报仇，只会叫你什么地方来什么地方去。</p>
<p>14.心可以热，但头一定要冷。</p>
<p>15.机会面前人人平等，抓住了机会就有可能改变人生。有人乘风而起，有人半日归零。</p>
<p>16.天气不会一直好下去的，人不会一直占上风的。</p>
<p>17.有主张、搞得定、摆得平，最后还有一点，要输得起。</p>
<p>18.人嘛，总要被一样东西套牢的。不是股票，就是房子。</p>
<p>19.自己看自己都好得不得了，都是人家的错，其实人家看你，浑身是毛病。乐观是好的，但最坏的打算还是要做的，什么事情都要未雨绸缪。</p>
<p>20.出人头地就是一个被人教训的过程。</p>
<p>21.口气不要比力气大。</p>
<p>22.人人心里有杆秤，什么时候可以同富贵，什么时候可以共患难，心里多少都有数的。</p>
<p>23.目标从来都不遥远，一步步，一天天，只管全力以赴，剩下的交给时间。</p>
<p>24.人总要赶一头，要么走要么留，唯独不好后悔，后悔没药可救的。</p>
<p>25.人情就是欠来欠去的，就跟刷墙一样，刷过来刷过去，所以这个人情才会越来越深厚。</p>
<p>26.哪里有那么多真的假的，眼前看到的就是真的，走掉的都是假的。</p>
<p>27.当时我看不清楚她的样子，十年以后，我还是没有看清她的样子，但我看清了自己。阿宝年少时是一名工厂工人，后来遭到了初恋女友的“抛弃”，当时的阿宝并不完全了解对方，看不清楚眼前人。十年以后，阿宝还是没有看懂她，但他已经知道自己要做什么、该怎么去做了。</p>
<p>28.蟋蟀再勇敢，牙齿再尖，斗到最后，还是输的，要死的，人也是一样。</p>
<p>29.为什么我不可以是自己的码头？27号不是我的码头，宝总也不是，我是我自己的码头。</p>
<p>30.宁敲金钟一记，不打破鼓千声。出自《红楼梦》第七十二回，比喻宁愿和能人作短暂的接触，也不屑和平庸低劣的人多打交道。</p>
<p>31.关山难越，闯过去是扬眉吐气，又一程山高水远，闯不过去变成了教训，警示后来人。</p>
<p>32.今天的太阳，晒不到明天的衣裳。时间，决定一切。</p>
<p>33.在老天爷看来，都是必然的。一种选择，一种人生，不是你晓得对跟错，就能够逃得掉的。</p>
<p>34.人生两个问题，第一，找到问题，第二，把它解决掉。</p>
<p>35.只有看到未来，才会有未来。</p>
]]></content><link href="https://github.com/goohugo/myblog/issues/31"/><published>2024-01-10T10:23:45+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/30</id><title>WeeklyReport 2024</title><updated>2025-01-03T08:43:41.869148+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>English, code, write, speech, read，这个时代复利最高的五件事。</p>
</blockquote>
<ul>
<li>
<strong>D52</strong><ul>
<li>其它- 生产大礼包组装任务</li>
</ul>
</li>
<li>
<strong>D51</strong><ul>
<li>电商 - 实现仓库销售单与电商调拨单比对功能</li>
</ul>
</li>
<li>
<strong>D50</strong><ul>
<li>生产 - 产品结构图汇总功能优化</li>
</ul>
</li>
<li>
<strong>D49</strong><ul>
<li>仓库 - 生产存储过程sql语句优化</li>
<li>其它- 生产大礼包组装任务</li>
</ul>
</li>
<li>
<strong>D48</strong><ul>
<li>仓库 - 销售单维护新增电商退货数据导入功能</li>
<li>仓库 - 调拨单维护新增待处理仓库库存数据批量加载功能</li>
</ul>
</li>
<li>
<strong>D47</strong><ul>
<li>系统 - 生产仓库电商代码整合</li>
<li>营销 - 生产礼包BOM单维护</li>
</ul>
</li>
<li>
<strong>D46</strong><ul>
<li>电商 - 有赞平台活动订单下载问题修复；</li>
<li>加盟 - 其他入库单入库单价异常问题修复</li>
</ul>
</li>
<li>
<strong>D45</strong><ul>
<li>加盟 - 会员管理优化，支持修改会员手机号</li>
<li>电商 - 进销存统计功能优化</li>
<li>生产 - 仓库进销存功能优化</li>
<li>电商 - 天猫店铺发货后批量修改快递公司和单号</li>
</ul>
</li>
<li>
<strong>D44</strong><ul>
<li>电商 - 未发货订单提醒优化</li>
<li>生产- 部分页面功能查询速度优化</li>
<li>仓库 - 生产入库单当天订单可以反审核修改</li>
<li>电商 - 多个快递相同产品支持批量打印</li>
</ul>
</li>
<li>
<strong>D43</strong><ul>
<li>电商 - 有赞平台订单优惠金额取值问题修复</li>
<li>生产- 生产派工领料单打印功能</li>
<li>生产- BOM单维护优化</li>
</ul>
</li>
<li>
<strong>D42</strong><ul>
<li>电商 - 有赞电子面单打印接口编写</li>
<li>电商 - 有赞平台订单下载和发货接口编写</li>
</ul>
</li>
<li>
<strong>D41</strong><ul>
<li>电商 -小红书电子面单接口编写</li>
<li>生产- 协助财务进行生产原材料仓库台账调整</li>
</ul>
</li>
<li>
<strong>D40</strong><ul>
<li>国庆节快乐</li>
</ul>
</li>
<li>
<strong>D39</strong><ul>
<li>仓库 - 仓库选中产品时，只显示产成品和包装物</li>
<li>电商 - 给发货部安装部署得物快递打印工具</li>
</ul>
</li>
<li>
<strong>D38</strong><ul>
<li>电商 - 协助打印得物平台订单</li>
<li>生产 - BOM单维护</li>
<li>门店 - 中秋活动设置 新价格体系调整</li>
</ul>
</li>
<li>
<strong>D37</strong><ul>
<li>门店 - 中秋节活动设置</li>
<li>生产 - 外包车间包装任务</li>
</ul>
</li>
<li>
<strong>D36</strong><ul>
<li>加盟 - 商品管理模块优化</li>
<li>门店- 手机心意卡兑换服务优化</li>
</ul>
</li>
<li>
<strong>D35</strong><ul>
<li>加盟 - 用户管理问题、加盟赊销客户价格问题修复</li>
<li>门店 - 手机心意卡兑换程序优化</li>
</ul>
</li>
<li>
<strong>D34</strong><ul>
<li>电商 - 抖音新店开放平台对接配置</li>
</ul>
</li>
<li>
<strong>D33</strong><ul>
<li>加盟 - 销售入库单打印异常问题修复</li>
</ul>
</li>
<li>
<strong>D32</strong><ul>
<li>电商 -拼多多打印发货人地址错误修复</li>
<li>门店 - 其他入库出库新增按盘点结果导入产品，快速调整库存</li>
</ul>
</li>
<li>
<strong>D31</strong><ul>
<li>电商 - 百大易购聚水潭接口测试</li>
</ul>
</li>
<li>
<strong>D30</strong><ul>
<li>门店 -  合肥二级仓库散称商品库存问题调整</li>
<li>生产 -  外包车间包装任务</li>
</ul>
</li>
<li>
<strong>D29</strong><ul>
<li>电商 - 小红书订单发货接口编写</li>
</ul>
</li>
<li>
<strong>D28</strong><ul>
<li>电商 - 百大易购聚水潭接口编写</li>
<li>电商 - 小红书退款订单接口编写</li>
<li>门店 - 散称柜台单品8折活动设置</li>
</ul>
</li>
<li>
<strong>D27</strong><ul>
<li>电商 - 抖音小店新疆西藏中转订单标记</li>
</ul>
</li>
<li>
<strong>D26</strong><ul>
<li>电商 - 小红书下载订单服务编写</li>
<li>电商 - 拼多多新店ERP服务对接配置</li>
</ul>
</li>
<li>
<strong>D25</strong><ul>
<li>电商 - 京东开发平台应用评分安全项目整改处理</li>
</ul>
</li>
<li>
<strong>D24</strong><ul>
<li>电商 - 小红书电商接口编写调试</li>
<li>门店 - 按客户归属进行销售统计新增按门店客户统计</li>
<li>生产 - 修复仓库管理汇总统计按制单人姓名汇总统计结果</li>
</ul>
</li>
<li>
<strong>D23</strong><ul>
<li>门店 -  门店端午活动设置</li>
<li>门店 - 心意卡兑换程序优化</li>
</ul>
</li>
<li>
<strong>D22</strong><ul>
<li>电商 - 订单管理功能店铺名称控件优化，提高使用效率</li>
</ul>
</li>
<li><strong>D21</strong></li>
<li>
<strong>D20</strong><ul>
<li>电商 - 京东用户脱敏三要素改造任务</li>
</ul>
</li>
<li>
<strong>D19</strong><ul>
<li>电商 - 拼多多订单合并发货接口更新</li>
<li>电商 -针对部分平台秒退款导致发货问题，需要对发货接口进行优化升级</li>
</ul>
</li>
<li>
<strong>D18</strong><ul>
<li>门店 - 五一劳动节直营门店活动设置</li>
<li>五一假期快乐</li>
</ul>
</li>
<li>
<strong>D17</strong><ul>
<li>门店 - 心意卡手机兑换系统优化(代码框架搭建)</li>
<li>生产 - 下车间处理退换货</li>
</ul>
</li>
<li>
<strong>D16</strong><ul>
<li>生产 - 生产入库产品标签功能设计</li>
<li>生产 - 定制产品Bom清单设置</li>
</ul>
</li>
<li>
<strong>D15</strong><ul>
<li>电商 - 按订单编号查询产品明细并标记付款</li>
<li>生产 - 产品营养标签打印功能设计</li>
</ul>
</li>
<li>
<strong>D14</strong><ul>
<li>生产 - 生产入库新增日报登记入口，方便快捷登记</li>
<li>生产 -  产品合格证打印功能</li>
</ul>
</li>
<li>
<strong>D13</strong><ul>
<li>生产 - 生产日报维护功能上线运行</li>
</ul>
</li>
<li>
<strong>D12</strong><ul>
<li>门店 - 合肥临期商品买一赠一活动设置</li>
<li>加盟 - 加盟商系统(滨湖中山路店)重新安装</li>
</ul>
</li>
<li>
<strong>D11</strong><ul>
<li>电商 - 订单查询新增付款标记</li>
<li>生产 - 生产日报维护代码优化</li>
</ul>
</li>
<li>
<strong>D10</strong><ul>
<li>生产 - 生产日报维护代码编写</li>
<li>门店 - 3月花漾女神节季活动设置</li>
</ul>
</li>
<li>
<strong>D09</strong><ul>
<li>电商 - 订单发货接口优化，首次发货失败，不设置失败状态，可二次执行发货接口进行发货</li>
<li>电商 - 天猫旗舰店部分退款订单发货失败问题修复</li>
</ul>
</li>
<li>
<strong>D08</strong><ul>
<li>电商 -未扫描产品统计新增总部仓库产品库存</li>
<li>电商 - 售后退货订单支持多选导入</li>
<li>电商 - 优化包裹称重异常时增加语音提示；</li>
</ul>
</li>
<li>
<strong>D07</strong><ul>
<li>新年快乐</li>
</ul>
</li>
<li>
<strong>D06</strong><ul>
<li>门店  - 年货节活动产品设置</li>
<li>2024 新年快乐</li>
</ul>
</li>
<li>
<strong>D05</strong><ul>
<li>电商 - 未扫描商品数量统计新增总仓库存数量</li>
<li>系统 - 后台服务优化退款检测代码</li>
</ul>
</li>
<li>
<strong>D04</strong><ul>
<li>电商 - 顺丰电子面单切换为一联单130*76</li>
<li>门店 - 修复手机心意卡兑换后查询物流信息接口</li>
</ul>
</li>
<li>
<strong>D03</strong><ul>
<li>电商 -订单审核时，特定实物卡订单需要提醒客服发指定快递</li>
<li>生产 - 生产单维护新增产品优化</li>
</ul>
</li>
<li>
<strong>D02</strong><ul>
<li>电商 - 优化复合满就送代码</li>
<li>电商 - 产品目录组合产品添加功能优化</li>
<li>门店 - 心意卡兑换商品界面隐藏产品价格</li>
<li>生产 - 生产维护员只看自己的生产单   </li>
</ul>
</li>
<li>
<strong>D01</strong><ul>
<li>电商 - 从营销产品同步增加电商产品</li>
<li>营销 - 裸装产品维护(系统台账、bom单添加)</li>
</ul>
</li>
</ul>
]]></content><link href="https://github.com/goohugo/myblog/issues/30"/><category term="Life"/><category term="Top"/><published>2024-01-06T05:49:57+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/29</id><title>数据库更新表数据，从另一个表中取值</title><updated>2025-01-03T08:43:42.223691+00:00</updated><content type="html"><![CDATA[<h2>SQL SERVER</h2>
<pre><code>UPDATE  A set A.C=B.C 
from  tableA  as A（别名）,tableB as  B （别名）
where A.列= B.列
</code></pre>
<h2>MySQL</h2>
<pre><code>UPDATE tableA  as A
inner join tableB as  B  
on  A.列= B.列
set  A.C=B.C 
</code></pre>
<p>当A表与B表某个字段值相等时，更新A表某列值等于B表某列值</p>
<h2>DB2</h2>
<pre><code>UPDATE A_TEST as atest
set atest.ORG_CODE=(select ctest.code from C_TEST ctest where atest.id = ctest.id)
where atest.id in  (select ctest.id FROM TEST ctest);
</code></pre>
]]></content><link href="https://github.com/goohugo/myblog/issues/29"/><category term="Technical Articles"/><published>2023-10-25T07:58:59+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/28</id><title>获取 hash</title><updated>2025-01-03T08:43:42.577057+00:00</updated><content type="html"><![CDATA[<p>Mirror 内部做了一层 GitHub API token 的字符转换，解决不小心把 token 上传到 GitHub 后被删的问题</p>
<p>下面是获取 <code>hash</code> 的步骤</p>
<ol>
<li>获取 <a href="https://github.com/LoeiFy/Mirror/wiki/Token-%E8%AE%BE%E7%BD%AE">token</a></li>
<li>获取你的主域名 <code>hostname</code>，例如 <code>https://blog.1016913.xyz</code> 的主域名为 <code>blog.1016913.xyz</code></li>
<li>打开 <a href="https://blog.1016913.xyz/">Mirror</a> 网站，并打开 <code>开发者工具</code> 界面</li>
<li>在开发者工具的 <code>console</code> tab 页面，输入 js 代码 <code>window.encrypt(&#x27;你的token&#x27;, &#x27;你的主域名&#x27;)</code></li>
</ol>
<p><img src="https://user-images.githubusercontent.com/2193211/54478294-7689cc00-484b-11e9-9f45-8157cf92d180.png" alt="example" /></p>
<p>得到的字符就是 <code>hash</code> 串</p>
]]></content><link href="https://github.com/goohugo/myblog/issues/28"/><category term="Technical Articles"/><published>2023-08-11T01:54:02+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/27</id><title>Mirror 中文教程</title><updated>2025-01-03T08:43:42.985989+00:00</updated><content type="html"><![CDATA[<ol>
<li>
<p>下载 <code>Mirror</code> 的最新版本 <a href="https://github.com/LoeiFy/Mirror/raw/master/release/mirror.zip">地址</a></p>
</li>
<li>
<p>获取你的 <code>hash</code> <a href="https://github.com/haoz0x139/myblog/issues/28">地址</a></p>
</li>
<li>
<p>修改 <code>index.html</code></p>
</li>
</ol>
<pre><code class="language-html">...

&lt;script&gt;
window.config = {
  organization: false, // 默认是 false，如果你的项目是属于 GitHub 组织 的，请设置为 true
  order: &#x27;UPDATED_AT&#x27;, // 文章排序，以 创建时间 或者 更新时间，可选值 &#x27;UPDATED_AT&#x27;，&#x27;CREATED_AT&#x27;
  title: &#x27;Mirror&#x27;, // 博客标题
  user: &#x27;LoeiFy&#x27;, // GitHub 用户名，必须
  repository: &#x27;Recordum&#x27;, // GitHub 项目名，指定文章内容来源 issues，必须
  authors: &#x27;LoeiFy,author1&#x27;, // 博客作者，以 &#x27;,&#x27; 分割，GitHub 用户名默认包含在内
  ignores: &#x27;17,13&#x27;, // 文章忽略的 issues ID
  host: &#x27;&#x27;, // 博客的主域名，不填自动获取，请注意这个值会影响 hash 的值
  hash: &#x27;&#x27;, // 必须
  perpage: 5, // 分页
}
&lt;/script&gt;

...
</code></pre>
<p>保存 <code>index.html</code>， 然后将所有文件 push 到 <code>gh-pages</code> 分支或者 <code>master</code> 分支的 <code>docs</code> 目录</p>
]]></content><link href="https://github.com/goohugo/myblog/issues/27"/><category term="Technical Articles"/><published>2023-08-11T01:51:16+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/26</id><title>WeeklyReport 2023</title><updated>2025-01-03T08:43:43.341291+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>English, code, write, speech, read，这个时代复利最高的五件事。</p>
</blockquote>
<ul>
<li>
<strong>D52</strong><ul>
<li>营销 - 心意卡制作准备——卡号生成</li>
<li>生产 - 下车间组装大礼包</li>
<li>部分系统存储过程查询速度优化</li>
</ul>
</li>
<li>
<strong>D51</strong><ul>
<li>电商 - 解决抖音电子面单分包单号获取异常问题</li>
<li>营销 - 双旦营销活动设置</li>
</ul>
</li>
<li>
<strong>D50</strong><ul>
<li>电商 - 测试电商仓库按批次出库功能</li>
<li>电商 - 解决京东虎符接口调用异常问题</li>
</ul>
</li>
<li>
<strong>D49</strong><ul>
<li>门店-双12活动设置；</li>
<li>电商-单据入库时按入库日期生成批号，方便出库时选择；</li>
<li>电商-单据出库选择产品按批次出库；</li>
</ul>
</li>
<li>
<strong>D48</strong><ul>
<li>加盟-马鞍山加盟商系统迁移安装</li>
<li>营销-协助营销部打印香榧合格证</li>
<li>加盟-马鞍山加盟店香港城心意卡发放</li>
<li>电商-仓库出库按批号出库功能代码编写</li>
</ul>
</li>
<li>
<strong>D47</strong><ul>
<li>系统 - 将敏感数据 获取方式改用Web服务调取</li>
<li>营销 - 按产品进行销售金额统计报表增加产品数量统计</li>
</ul>
</li>
<li>
<strong>D46</strong><ul>
<li>电商 - 优化拼多多退款检测接口</li>
<li>加盟 - 系统数据库表索引优化，加快系统数据检索速度</li>
</ul>
</li>
<li>
<strong>D45</strong><ul>
<li>电商 - 订单退款后，再次退款会被重新检测并标记</li>
<li>电商 - 解决快手小店电子面单取号异常问题</li>
<li>加盟 - 马鞍山加盟商系统重新安装</li>
</ul>
</li>
<li>
<strong>D44</strong><ul>
<li>电商 - 解决批量打印分包快递单</li>
<li>系统 - 登录页面 样式在缩放界面下图片变形问题</li>
<li>加盟 - 太湖路店安装加盟系统</li>
<li>加盟 - 商品管理页面可以禁用商品</li>
</ul>
</li>
<li>
<strong>D43</strong><ul>
<li>营销 - 门店双11活动设置</li>
<li>加盟 - 加盟商四里河万科店系统重装</li>
<li>ERP -  解决提醒服务占用CPU过高问题</li>
<li>ERP - 优化仓库和生产价格显示权限控制</li>
</ul>
</li>
<li>
<strong>D42</strong><ul>
<li>生产 - 生产单维护优化，新增生产单时，同时生成派工领料信息</li>
<li>生产 - bom单关联领料人信息，相关操作自动显示</li>
<li>生产 - 生产单维护新增来自要货申请单</li>
</ul>
</li>
<li>
<strong>D41</strong><ul>
<li>生产 - 删除大部分视图，改用存储过程，优化系统代码</li>
<li>生产 - 增加生产单入库状态，生产单不生产的产品可以自行删除</li>
</ul>
</li>
<li>
<strong>D40</strong><ul>
<li>中秋 国庆 假期快乐</li>
</ul>
</li>
<li>
<strong>D39</strong><ul>
<li>电商 - 订单审核和订单查询优化</li>
<li>营销 - 客户、BOM单添加</li>
<li>生产 - 数据库优化 视图改存储过程</li>
</ul>
</li>
<li>
<strong>D38</strong><ul>
<li>电商 - 快递单打印新增预览订单面单功能</li>
<li>电商 - 编写按批号自动出库代码</li>
<li>门店 - CefSharp.Browser 新增右键菜单</li>
<li>电商 - 修复订单收入汇总产品明细数据显示错误</li>
<li>电商 - 订单审核代码优化</li>
</ul>
</li>
<li>
<strong>D37</strong><ul>
<li>系统 - 系统弹窗提醒代码优化</li>
<li>仓库 - 销售单、调拨单维护优化</li>
<li>电商 - 发货超时订单提醒功能优化</li>
</ul>
</li>
<li>
<strong>D36</strong><ul>
<li>电商 - 数据库优化更新</li>
<li>电商 - 线下订单发货单打印修复</li>
<li>电商 - 合并订单物流单号保存异常问题</li>
</ul>
</li>
<li>
<strong>D35</strong><ul>
<li>生产 - 生产入库导入单据后，自动设置领料信息</li>
<li>电商 - 产品目录新增库存同步功能</li>
<li>电商 - 订单收入汇总 付款明细新增积分优化数据项</li>
<li>生产/仓库 - 单据日期新增当天-本月-上月选择项</li>
</ul>
</li>
<li>
<strong>D34</strong><ul>
<li>电商 - 修复复制订单无法打印部分快递单问题</li>
<li>门店 - 合肥五家门店老日期清库存活动产品设置</li>
<li>生产 - 生产入库单维护，来自领料单时，自动设置领料信息</li>
</ul>
</li>
<li>
<strong>D33</strong><ul>
<li>门店 - 协助财务对门店盘点结果进行系统库存调整</li>
<li>电商 - 礼盒订单出库前，可以使用手机扫描物流单号，查询订单商品</li>
</ul>
</li>
<li>
<strong>D32</strong><ul>
<li>电商 - 单据出库统计汇总功能异常修复</li>
<li>电商 - 发货部新增一台扫描称重电脑，调试电子秤</li>
<li>生产 - 月饼礼盒BOM单添加</li>
<li>生产 - 原材料批次异常问题修复</li>
</ul>
</li>
<li>
<strong>D31</strong><ul>
<li>电商 - 订单扫描和包裹称重合并，即扫描后立即称重</li>
<li>电商 - 单据入库统计按店铺名称分组异常修复</li>
<li>电商 - 抖音小店合并订单新增判断条件</li>
<li>电商 - 订单商品列表里退款商品和赠送商品样式更新</li>
</ul>
</li>
<li>
<strong>D30</strong><ul>
<li>电商 - 物流信息新增详细地址信息</li>
<li>电商 - 按月(年)度统计电商产品销售数量</li>
<li>生产 - BOM日常维护</li>
<li>门店 - 新增客户和价格维护</li>
</ul>
</li>
<li>
<strong>D29</strong><ul>
<li>报表 - 电商订单信息查询(含产品)</li>
<li>报表 -心意卡电商发货信息查询</li>
<li>报表 -按月统计生产入库数量</li>
</ul>
</li>
<li>
<strong>D28</strong><ul>
<li>报表 -按客户归属进行销售金额统计</li>
<li>报表 -按产品进行销售金额统计</li>
<li>生产 -精品罐产品BOM单添加</li>
<li>门店 - 微信满减券活动设置</li>
</ul>
</li>
<li>
<strong>D27</strong><ul>
<li>生产 - 包装物原材料采购价格统计优化，新增采购数量统计</li>
<li>门店 - 配合门店删除已售完的活动商品</li>
<li>营销 - 精品罐新品建档，下周新增BOM单</li>
<li>日常 - 门店生产系统维护</li>
</ul>
</li>
<li>
<strong>D26</strong><ul>
<li>电商 - 优化电商主页数据，新增订单状态统计</li>
<li>生产 - 包装物原材料采购价格统计</li>
</ul>
</li>
<li>
<strong>D25</strong><ul>
<li>电商 - 修复销售金额对比分析查询异常问题</li>
<li>生产 - 产品采购历史平均价格对比情况</li>
<li>电商 - 优化会员统计分析售后统计异常问题</li>
</ul>
</li>
<li>
<strong>D24</strong><ul>
<li>电商 - 优化电商主页数据</li>
<li>生产 - 新增生产首页数据</li>
<li>仓库	- 修复其他出库单价格异常问题</li>
<li>电商 - 修复售后订单因没有收货区域导致无法补发问题  </li>
</ul>
</li>
<li>
<strong>D23</strong><ul>
<li>电商- 首页显示数据优化，检索日期由支付时间改为发货日期</li>
<li>加盟 - 优化心意卡刷卡界面，修复短信发送接口</li>
<li>加盟 - 设置调用总部Web服务超时时间</li>
</ul>
</li>
<li>
<strong>D22</strong><ul>
<li>电商 - 解决快手小店可取号但无法打印问题</li>
<li>电商 - 协助电商进行京东云鼎和阿里聚石塔续费申请</li>
<li>门店 - 六月浓情端午活动设置</li>
</ul>
</li>
<li>
<strong>D21</strong><ul>
<li>电商 -  解决快手小店电子面单自定义区域打印问题</li>
<li>门店 -  “斛生记、谢裕大”引进品的最低销售价设置</li>
<li>电商 -  解决补发订单地址读取异常问题</li>
</ul>
</li>
<li>
<strong>D20</strong><ul>
<li>门店 - 合肥直营门店2023年1月老日期大库存产品促销活动设置-买一赠一</li>
<li>电商 - 顺丰电子面单打印默认标快件，如果设置加急处理，打印面单上标识发航空件</li>
<li>电商 - 调整顺丰京东电子面单快件产品类别区分顺丰次日和顺丰隔日</li>
<li>电商 - 解决京东订单取消加密后，打印快递单地址不变问题</li>
</ul>
</li>
<li>
<strong>D19</strong><ul>
<li>电商 - 部分店铺订单导入时，指定默认快递</li>
<li>电商 - 进销存电商合并库存表格新增销售出库列</li>
<li>营销 - 海螺订单支付金额调整</li>
<li>电商 - 快手小店电子面单打印格式调整，未测试</li>
</ul>
</li>
<li>
<strong>D18</strong><ul>
<li>电商 - 部分窗体页面样式调整</li>
<li>仓库 - 选择历史订单做退单时，单价将保持不变</li>
<li>快手后台订单下载、发货、退款等接口服务优化</li>
<li>抖音下单日期异常问题修复</li>
</ul>
</li>
<li>
<strong>D17</strong><ul>
<li>拼多多开放平台accesstoken过期，手动重新获取</li>
<li>拼多多店铺应用session过期自动获取代码编写</li>
<li>系统 - 新增快手小店电子面单打印代码编写</li>
</ul>
</li>
<li>
<strong>D16</strong><ul>
<li>生产 - 海螺订单导入电商系统发货功能优化</li>
<li>系统 - 新增快手小店发货接口代码</li>
<li>系统 - 新增快手小店退款检测接口代码</li>
</ul>
</li>
<li>
<strong>D15</strong><ul>
<li>生产单维护新增生产领料单打印功能；</li>
<li>设置存储过程查找超时时间为3分钟</li>
<li>服务 - 快手小店下载服务优化</li>
</ul>
</li>
<li>
<strong>D14</strong><ul>
<li>新增两款新品 25g芥末（咸蛋黄味）脆皮夏威夷果BOM清单</li>
<li>5月快乐出游季直营门店活动设置</li>
<li>优化订单扫描验证功能，新增订单编号扫描功能</li>
<li>发货单打印格式优化</li>
<li>订单审核复制订单可刷新价格</li>
</ul>
</li>
<li>
<strong>D13</strong><ul>
<li>重写包裹称重代码</li>
<li>协助吴提供科大智能心意卡兑换结果</li>
<li>新增部分新产成品和包装物</li>
<li>BOM清单设置优化-新增BOM清单功能按钮来自BOM单代码优化</li>
<li>屏蔽服务无法连接到远程服务器错误的提示</li>
<li>定时发送每日待发货产品列表信息到发货员钉钉</li>
</ul>
</li>
<li>
<strong>D12</strong><ul>
<li>电商 - 包裹称重功能优化，提高重量显示速度</li>
<li>电商 - 地址加密订单拆单单号无法获取问题</li>
<li>门店 - 合肥门店散货新罐等临期产品买一赠一活动设置</li>
<li>电商 - 取消抖音订单定时下载功能，开启自动下载抖音订单功能</li>
</ul>
</li>
<li>
<strong>D11</strong><ul>
<li>营销-协助解决69绩效考核表电商部分与电商系统订单收入汇总差异</li>
<li>电商-包裹称重功能优化</li>
<li>电商-部署定时下载程序到聚石塔，满足抖音定时服务需求</li>
</ul>
</li>
<li>
<strong>D10</strong><ul>
<li>生产 - 仓库领料修复包装物单价异常问题</li>
<li>电商 - 抖音订单取消地址解密功能，继续抖店云外调用API，无需入抖店云。</li>
<li>电商 - 切换抖音订单下载和退款接口接入方式，由手动切换为定时下载模式</li>
<li>服务 - 新增后台任务调度服务，目前已加入抖音定时下载作业和电商销售情况定时发送作业</li>
</ul>
</li>
<li>
<strong>D9</strong><ul>
<li>电商 - 抖音小店自动下单服务改为手动下载模式</li>
<li>电商 - 订单收入汇总退款金额统计问题修复</li>
<li>门店 - 3月踏青季直营活动设置</li>
<li>门店 - 四牌楼店现金卡销售单据错误调整</li>
</ul>
</li>
<li>
<strong>D8</strong><ul>
<li>门店 宣城门店添加部分临保产品买一赠一活动</li>
<li>心意卡兑换功能 当客户心意卡是现金卡而非实物卡时，程序自动跳转到商城积分充值页</li>
<li>电商 - 代理商价格政策维护</li>
<li>电商 - 订单审核新增产品时，选择代理商店铺时，自动获取代理商价格 </li>
<li>服务 - 修复拼多多订单分页导致下载异常问题</li>
</ul>
</li>
<li>
<strong>D7</strong><ul>
<li>仓库 - 销售给电子商务的销售单新增钉钉消息提醒功能</li>
<li>电商 - 订单审核客户发货地址解析优化</li>
<li>电商 - 订单分包打印日志记录优化</li>
<li>门店 - 合肥直营门店老日期大库存产品促销活动设置</li>
</ul>
</li>
<li>
<strong>D6</strong><ul>
<li>电商 - 协助财务查找电商调拨入库数据与仓库销售数据差异</li>
<li>仓库 - 销售单维护新增电商销售单审核打印时，发送钉钉消息给相关负责人</li>
<li>系统 -  工作电脑反应慢，重新安装系统</li>
</ul>
</li>
<li>
<strong>D05</strong><ul>
<li>电商 - 部分补发订单默认开启发货短信通知</li>
<li>电商 - 修复部分订单扫描异常问题</li>
<li>电商 - 天猫订单修改地址新增提醒功能</li>
<li>电商 - 售后订单新增退货商品筛选功能</li>
<li>系统 - 优化后台服务功能，拆分退款、迁移订单、合并会员和出库操作</li>
<li>仓库 - 仓库进销存查询新增商品单位筛选</li>
<li>加盟-修复销售出库散称数量未更改时情况下导致商品价格异常问题</li>
</ul>
</li>
<li>
<strong>D04</strong><ul>
<li>新年快乐 </li>
</ul>
</li>
<li>
<strong>D03</strong><ul>
<li>仓库 - 进销存结存列增加统计功能</li>
<li>服务 - 工行退款检测问题修复</li>
</ul>
</li>
<li>
<strong>D02</strong><ul>
<li>电商 - 未扫描商品数量统计优化，为下达生产计划提供参考数据</li>
<li>电商 - 待处理订单可以直接作废、新增扫描类型显示</li>
<li>生产 - Bom清单批量调整（散二级次品奶油椒盐手剥核桃）</li>
<li>电商 - 扫描出库修改控制礼包显示方式</li>
</ul>
</li>
<li>
<strong>D01</strong><ul>
<li>生产 - 团购商品Bom单添加</li>
<li>电商 - 强制称重成功后，新增语音提示功能</li>
<li>电商 - 修复订单打印日期筛选功能问题</li>
<li>电商 - 线下订单快递单号填充自动为订单编号</li>
<li>电商 - 协助电商解决邮政小包部分订单更换快递打印问题</li>
</ul>
</li>
</ul>
]]></content><link href="https://github.com/goohugo/myblog/issues/26"/><category term="Life"/><published>2023-08-02T05:57:13+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/25</id><title> EF-查询缓存</title><updated>2025-01-03T08:43:43.697482+00:00</updated><content type="html"><![CDATA[<p>同一个DbContext实例，EF会对查询过的数据进行缓存。对DbContext的生存期的管理需根据当前的应用来处理（如web、win），尽量不要采用全局的DbContext。也可在查询中采用AsNoTracking避免从缓存中取数据。</p>
<p>1、问题</p>
<p>构建一个全局的或某个业务场景内唯一的DbContext</p>
<pre><code>public OTBll()
{
　　efContext = new AppDbContext();
　　this.OT_DataFlowRepository = new EFRepository&lt;OT_DataFlow&gt;(efContext);　
}
</code></pre>
<p>在此场景内间隔查询数据</p>
<pre><code>HR_SignSealPdf entity =context.HR_SignSealPdf.FirstOrDefault(e =&gt;
　　e.SignId == item.SignId &amp;&amp; e.Cate == item.Cate);
entity.PdfUploadErrs += 1;
</code></pre>
<p>SSMS修改PdfUploadErrs后，仍会从entity.PdfUploadErrs的值上累加</p>
<pre><code>UPDATE HR_SignSealPdf SET PdfUploadErrs=0
</code></pre>
<p>2、解决办法</p>
<p>（1）每次构建一个新的DbContext实例，使用完毕就释放</p>
<pre><code>using (var context = new AppDbContext())
{
}
</code></pre>
<p>（2）AsNoTracking返回新的查询实体</p>
<pre><code>efContext.HR_SignSealPdf.AsNoTracking()
</code></pre>
<p>反编译的代码</p>
<pre><code>/// &lt;summary&gt;返回一个新查询，其中返回的实体将不会在 &lt;see cref=&quot;T:System.Data.Entity.DbContext&quot; /&gt; 或 &lt;see cref=&quot;T:System.Data.Entity.Core.Objects.ObjectContext&quot; /&gt; 中进行缓存。此方法通过调用基础查询对象的 AsNoTracking 方法来运行。如果基础查询对象没有 AsNoTracking 方法，则调用此方法将不会有任何影响。&lt;/summary&gt;
    /// &lt;returns&gt;应用 NoTracking 的新查询，如果不支持 NoTracking，则为源查询。&lt;/returns&gt;
    /// &lt;param name=&quot;source&quot;&gt;源查询。&lt;/param&gt;
    public static IQueryable AsNoTracking(this IQueryable source)
    {
      System.Data.Entity.Utilities.Check.NotNull&lt;IQueryable&gt;(source, nameof (source));
      DbQuery dbQuery = source as DbQuery;
      if (dbQuery == null)
        return QueryableExtensions.CommonAsNoTracking&lt;IQueryable&gt;(source);
      return (IQueryable) dbQuery.AsNoTracking();
    }
</code></pre>
<p>3、优化</p>
<p>web端可考虑在当前操作线程内定义个唯一的DbContext，以提高效率</p>
<pre><code>//返回当前线程内的数据库上下文，如果当前线程内没有上下文，那么创建一个上下文，并保证上线问实例在线程内部是唯一的
public static VpoEntities GetCurrentDemoContext()
{
    //CallContext：是线程内部唯一的独用的数据槽（一块内存空间）
    //传递DbContext进去获取实例的信息，在这里进行强制转换。
    VpoEntities dbContext = CallContext.GetData(&quot;DbContext&quot;) as VpoEntities;
    if (dbContext == null) //线程在数据槽里面没有此上下文
    {
        dbContext = new VpoEntities(); //如果不存在上下文的话，创建一个EF上下文
        var adapter = (IObjectContextAdapter)dbContext;
        var objectContext = adapter.ObjectContext;
        objectContext.CommandTimeout = 1800;
 
        //我们在创建一个，放到数据槽中去
        CallContext.SetData(&quot;DbContext&quot;, dbContext);
    }
    return dbContext;
}
</code></pre>
<p><a href="https://www.cnblogs.com/hepc/p/10253414.html">原文地址</a></p>
]]></content><link href="https://github.com/goohugo/myblog/issues/25"/><category term="Development"/><published>2023-07-23T08:16:26+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/24</id><title>Ubuntu分区方案</title><updated>2025-01-03T08:43:44.079152+00:00</updated><content type="html"><![CDATA[<h1>Ubuntu分区方案</h1>
<p><a href="https://www.cnblogs.com/raina/p/11129375.html">原文地址</a></p>
<ul>
<li>swap: 4G(跟你自己内存一样大)；主分区；空间起始位置；用于交换空间</li>
<li>/boot: 300M(太小会导致软件无法升级)；逻辑分区；空间起始位置；EXT4；/boot</li>
<li>/: 30G；主分区；空间起始位置；EXT4；/</li>
<li>(可不分)/usr: 软件安装位置，大小剩下的1/3 - 1/2空间；逻辑分区；空间起始位置；EXT4；/usr</li>
<li>/home:** 文件存放位置，剩下的所有空间给它；逻辑分区；空间起始位置；EXT4；/home</li>
</ul>
<h1>Ubuntu单系统分区方案(1T)</h1>
<ul>
<li>swap: 12G(跟你自己内存一样大)；主分区；空间起始位置；用于交换空间</li>
<li>/boot: 500M逻辑分区；空间起始位置；EXT4；/boot</li>
<li>/: 100G；主分区；空间起始位置；EXT4；/</li>
<li>/usr: 100G；逻辑分区；空间起始位置；EXT4；/usr</li>
<li>/home: 剩下所有空间减去200M；逻辑分区；空间起始位置；EXT4；/home</li>
<li>efi: 逻辑分区；空间起始位置；EFI系统分区</li>
<li>安装启动引导器的设备选择efi那个分区</li>
</ul>
<p>已经使用 Ubuntu 快一年了，贴一张各分区使用情况图：</p>
<p><img src="https://github.com/haoz0x139/myblog/assets/124132611/bdf837bd-f326-4af7-a4a2-0e3a957ee0bc" alt="image" /></p>
]]></content><link href="https://github.com/goohugo/myblog/issues/24"/><category term="Technical Articles"/><published>2023-07-03T08:10:11+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/23</id><title>MySQL8绿色版安装简明教程</title><updated>2025-01-03T08:43:44.455423+00:00</updated><content type="html"><![CDATA[<h1>背景</h1>
<ul>
<li>开发安装MySQL8版本，但是直接使用安装包安装，无法设置安装路径，mysql会直接安装到系统盘。不喜欢这样，所以选择MySQL8绿色版安装</li>
</ul>
<h1>下载地址</h1>
<ul>
<li>官网下载：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a>
<img src="https://github.com/haoz0x139/myblog/assets/124132611/433303dc-14f4-49ab-9c2f-2848ba9eaf63" alt="官网下载" /></li>
</ul>
<h1>步骤</h1>
<ul>
<li>解压安装包</li>
<li>
增加my.ini文件<ul>
<li>my.ini是MySQL初始化配置文件，绿色版需要自己增加配置</li>
<li>文件内容：（红色安装路径自己替换）</li>
</ul>
</li>
</ul>
<pre><code>[mysql]
# 设置mysql客户端默认字符编码形式
default-character-set=utf8mb4

[mysqld]

#设置端口号，默认3306
port = 3306

# 设置mysql的安装目录
basedir=D:\mysql-8.0.19-winx64\
# 设置mysql数据库的数据存放目录
datadir=D:\mysql-8.0.19-winx64\data\
# 设置最大连接数
max_connections=200
# 允许连接失败的次数
max_connect_errors=10
# 服务端使用的字符集默认为utf8mb4
character-set-server=utf8mb4

# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
# 默认使用“mysql_native_password”插件认证
#mysql_native_password
default_authentication_plugin=mysql_native_password
[client]

# 设置mysql客户端连接服务端时默认使用的端口
port=3306
default-character-set=utf8mb4
#initPass: Cet:m/ioh8Bq
</code></pre>
<ul>
<li>
<p>初始化MySQL</p>
<ul>
<li>
<p>以管理员身份打开cmd</p>
</li>
<li>
<p>进入MySQL安装目录下得bin文件夹</p>
</li>
<li>
<p>执行初始化命令：mysqld --initialize --user=mysql --console</p>
</li>
<li>
<p>这时在mysql安装目录将会生成一个data文件夹，用来存放数据
<img src="https://github.com/haoz0x139/myblog/assets/124132611/4ac8c93d-2ea4-4d9e-8b16-ca22a84e6982" alt="image" /></p>
</li>
<li>
<p>这时将会得到你的root初始密码，用来第一次登陆数据库，很重要，一旦丢失，只能重装。 如下图红框内即是初始密码
<img src="https://github.com/haoz0x139/myblog/assets/124132611/5c6538af-356b-4d2a-8ec1-851dd3f141ed" alt="image" /></p>
</li>
</ul>
</li>
<li>
<p>安装MySQL服务</p>
<ul>
<li>执行命令mysql --install，安装成功，如下图，同时也能在windows服务中看到mysql服务
<img src="https://github.com/haoz0x139/myblog/assets/124132611/7ffa37ed-88fc-4b79-82ac-ff97474d0236" alt="image" /></li>
</ul>
</li>
<li>
<p>启动MySQL</p>
<ul>
<li>执行命令：net start mysql
<img src="https://github.com/haoz0x139/myblog/assets/124132611/302da648-a3ff-47f0-9f7b-ae2fef272e42" alt="image" /></li>
</ul>
</li>
<li>
<p>安装出现错误</p>
<ul>
<li>
<p>检查服务是否存在
<img src="https://github.com/haoz0x139/myblog/assets/124132611/0d4fa61b-998f-40b7-8faa-2b9ab3ee3ae3" alt="image" /></p>
</li>
<li>
<p>删除服务：sc delete mysql</p>
</li>
<li>
<p>删除安装路径下生成的data文件夹
<img src="https://github.com/haoz0x139/myblog/assets/124132611/fefc3d75-cb29-4731-b463-490d5779b435" alt="image" /></p>
</li>
<li>
<p>重新安装</p>
</li>
</ul>
</li>
</ul>
]]></content><link href="https://github.com/goohugo/myblog/issues/23"/><category term="Technical Articles"/><published>2023-06-13T00:19:10+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/22</id><title>Win10神州网信政府版安装过程</title><updated>2025-01-03T08:43:44.828810+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>Win10神州网信政府版（企业版G）下载地址
64位（也只有64位的版本）
ed2k://|file|CMGE_V2020-L.1207.iso|4736782336|8F2FC33635D79963CBB0A43C4A916200|/</p>
</blockquote>
<h2>安装要求：</h2>
<ul>
<li>处理器: 1 GHz 及以上x64兼容处理器</li>
<li>内存: 2GB 及以上</li>
<li>硬盘: 必须包含至少一块不可移动硬盘，20GB 及以上可用空间</li>
<li>显卡: 支持DirectX 9 及以上</li>
<li>显示器: 1024 x 768 分辨率及以上</li>
<li>网络：必须包含至少一种网络连接选择，如 Wi-Fi 或以太网适配器</li>
</ul>
<h2>安装步骤</h2>
<p><img src="https://github.com/haoz0x139/myblog/assets/124132611/6d023f91-d6dd-401d-9f40-17fe19e2c89f" alt="启动界面" /></p>
<p><img src="https://github.com/haoz0x139/myblog/assets/124132611/419e92c0-9cd0-46d3-813a-c4c6031d2a02" alt="选择操作系统" /></p>
<p><img src="https://github.com/haoz0x139/myblog/assets/124132611/1e1afe98-2ec9-4dcf-83db-4fddf5997c82" alt="拷贝系统文件。执行安装Windows" /></p>
<p><img src="https://github.com/haoz0x139/myblog/assets/124132611/92daf1ab-264b-400d-9fd0-ac9735545627" alt="系统桌面" /></p>
<p>win + X  打开管理员Windows PowerShell，输入下面的代码</p>
<pre><code>slmgr /upk
slmgr /ipk YYVX9-NTFWV-6MDM3-9PT4T-4M68B
slmgr /skms kms.03k.org
slmgr /ato
</code></pre>
<p>Enjoy it</p>
]]></content><link href="https://github.com/goohugo/myblog/issues/22"/><category term="Technical Articles"/><published>2023-06-04T07:24:35+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/21</id><title>科目三终于通过了</title><updated>2025-01-03T08:43:45.211104+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>2023年5月11日终于通过了科目三考试，总结下这次可以一把通过考试的原因。</p>
</blockquote>
<ul>
<li>科目三练车一般是两天加三个下午，每周四上午是安排我们驾校的学员参加考试；</li>
<li>我先跟着教练练了两三天后，后面几天，感觉状态越来越差，担心这次考不过，和教练说了下自己的顾虑，快考试的前一天去驾校取消了考试预约；后面，我仔细写了份我们科目三考试的笔记，记录详细的动作要领，每天早上看上一遍，脑子里再过一遍，进一步加深记忆！</li>
<li>第二周，教练让我去练车，这次就比上次强多了，至少，车开到哪里，需要怎么操作，换挡，踩刹车，都记得住，就是遇到突发情况，就容易乱。要不就是三加四换挡，换不好，几趟都是三加四跑不了。要不就是，起步后，下去150米处掉头，这一小段路上，一直磕磕绊绊，1+2+3，再减2挡掉头，前两天还搞得蛮好，后三天下午，车子多了，就手忙脚乱……</li>
<li>考试那天，我一大早，6点不到，就出门了，步行大概10多分钟，到6路站台，做6路车。大概40分钟就到了，7点20就到考试地点了。</li>
<li>到了8点，考试车来了，我们学员陆续签到，准备考试。等待的时间，是最难熬得，大概快10点左右，我正要准备走出候考室，被教练叫上，上了4号车，第一个起点考试的考生已经站在车外了。</li>
<li>我前面这个考生，一路上开的都挺好，就是每次踩刹车时，有点重，搞🉐考官很不爽。都快到3公里了，一个公交站台🚌忘了点刹车，第一次考试挂了，接着补考第二次，考到掉头时，误操作，原本挂2挡的，挂到4挡了，这样，他这次考试就没通过了，他第一把挺好，后来，我想来了下，应该是机动车挡住公交站台大半，导致他没注意到，忘了点刹车而挂掉吧！</li>
<li>轮到我考了，一路上都挺好，吸取教训，点刹车轻点，一路上，考官都没怎么说话，当我把车开到3公里牌子出处，感觉这次要成！</li>
<li>在最后靠边停车，没有正确理解考官的意图，慌乱中，考官一脚刹车，拉起手刹，回空档，熄火，让我赶紧下车。我还以为自己挂了，但又感觉哪里不对，当我听到考试合格的指令后，才反应过来，原来自己通过了考试。</li>
<li>感谢教练，没教练安排，可能不会把我排在后面一个上车，感谢考官，没有那一脚刹车，估计我也会像上一位一样，考第二遍，心态肯定要崩，也不会通过考试了。</li>
</ul>
]]></content><link href="https://github.com/goohugo/myblog/issues/21"/><category term="Life"/><published>2023-05-14T09:00:22+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/20</id><title>[笔记]纳瓦尔宝典</title><updated>2025-01-03T08:43:45.581487+00:00</updated><content type="html"><![CDATA[<h1>纳瓦尔宝典</h1>
<blockquote>
<p>作者：埃里克·乔根森；数量：19个笔记；时间：2023-03-1811:23:07</p>
</blockquote>
<ul>
<li>
<p><strong>找到天赋所在，积累专长</strong></p>
<ul>
<li>
<p>最好的工作与委任或学位无关。最好的工作是终身学习者在自由市场中的创造性表达。</p>
</li>
<li>
<p>致富最重要的技能是成为终身学习者，无论想学什么，你都得找到途径和方法。</p>
</li>
<li>
<p>在生活中，基本的算术能力比微积分更重要。同样，能够用简单的英语词汇清楚地表达比能够写诗、词汇量丰富或者说7种不同的语言重要得多。</p>
</li>
</ul>
</li>
<li>
<p><strong>找到杠杆</strong></p>
<ul>
<li>而编程、写书、录播客、发推特、拍视频这些事情不需要经过任何人的许可。由此可见，新杠杆就像一个均衡器，极大地缩小了人与人之间的差距，让社会变得更平等。</li>
</ul>
</li>
<li>
<p><strong>找到如玩耍般的工作</strong></p>
<ul>
<li>如何达到退休状态？ 第一种方法是存钱。只要存款够多，被动收入（不用动一根手指）就能满足开销。 第二种方法是把开销降为零——出家修行。 第三种方法是做自己热爱的事情，完全乐在其中，有钱没钱无所谓。所以，实现退休状态有很多种方法。</li>
</ul>
</li>
<li>
<p><strong>判断力</strong></p>
<ul>
<li>把时间花在省钱上是不会致富的。 省出时间来赚钱才是正确的思路。</li>
</ul>
</li>
<li>
<p><strong>学习决策技巧</strong></p>
<ul>
<li>
<p>当把成功归于自己时，你要更加谨慎，因为难免出现认知偏差。</p>
</li>
<li>
<p>具体地表扬，泛泛地批评。我努力遵循这个建议，虽然并不总能做到，但它确实给我的人生带来了积极的改变。</p>
</li>
</ul>
</li>
<li>
<p><strong>发现好的心智模型</strong></p>
<ul>
<li>
<p>需要学习算法、概率学和统计学，这些分支学科都非常重要。要吃透基础数学，真正掌握加减乘除、复利计算、概率论和统计学。</p>
</li>
<li>
<p>一个重大决策可能会影响未来十几年，甚至几十年的人生轨迹。创业可能需要10年时间。一段恋情可能会持续5年甚至更久。搬到一个城市可能会住上10年、20年。这些决定都将产生深远的影响。人做不到绝对确定，但是我们一定要在非常确定的情况下再做出决定。</p>
</li>
</ul>
</li>
<li>
<p><strong>学会热爱阅读</strong></p>
<ul>
<li>
<p>我建议多花些时间阅读微观经济学——从微观经济学入门课程开始。</p>
</li>
<li>
<p>如果对进化论感兴趣，那就去读一读达尔文的作品，不要从理查德·道金斯读起（尽管我认为他很棒）。先读达尔文，再读道金斯。</p>
</li>
<li>
<p>一颗平静的心，一个健康的身体，一个充满爱的家。这些东西是金钱买不到的，必须通过努力才能获得。</p>
</li>
</ul>
</li>
<li>
<p><strong>成功不一定带来幸福</strong></p>
<ul>
<li>
<p>谁是你心目中的成功人士？ 大多数人对成功人士的定义都是赢得游戏的人，无论是什么游戏。如果你是运动员，你眼中的成功人士就是顶级运动员。如果你经商，你眼中的成功人士也许就是埃隆·马斯克。</p>
</li>
<li>
<p>在现实生活中，内心的平和状态不是一劳永逸的，也不会是一成不变的。心理状态总在不断变化。在大多数情况下，接受并顺应现实，是获得幸福的核心技能。[8]</p>
</li>
</ul>
</li>
<li>
<p><strong>幸福源于好习惯</strong></p>
<ul>
<li>五只黑猩猩理论”讲的是，通过观察最常与一只黑猩猩一起玩耍的五只黑猩猩，你就能准确预测这只黑猩猩的行为方式</li>
</ul>
</li>
<li>
<p><strong>于接受中寻找幸福</strong></p>
<ul>
<li>其实，我们没有什么遗产，没有什么可以留下的，也没有什么会永垂不朽。我们都会离开这个世界，我们的孩子也会离开这个世界；我们的成就终将化为尘土，人类文明也会化为尘土；我们的地球将变成尘埃，太阳系也会化作尘埃。从宏观角度看，宇宙已经存在了100亿年，并将继续存在100亿年。</li>
</ul>
</li>
<li>
<p><strong>选择关爱自己</strong></p>
<ul>
<li>从生理层面看，现代人的饮食结构不符合进化的目标。正确的饮食结构应该更接近旧石器时代，以蔬菜为主，辅以少量的肉类和浆果。</li>
</ul>
</li>
<li>
<p><strong>选择自我塑造</strong></p>
<ul>
<li>如果年纪更小，你可以每5年为一个时间段这样问自己。）坐下来认真思考自己过去每一年的经历和感受：“2007年，我在做什么，我感觉怎么样？2008年，我在做什么，我感觉怎么样？2009年，我在做什么，我感觉怎么样？”</li>
</ul>
</li>
<li>
<p><strong>图书</strong></p>
<ul>
<li>《人类简史：从动物到上帝》</li>
<li>《万物解释者：复杂事物的极简说明书》</li>
<li>《趣味物理寻答集》</li>
<li>《历史的教训》</li>
<li>《穷查理宝典：查理·芒格智慧箴言录》，查理·芒格、彼得·考夫曼（编）</li>
<li>《七堂极简物理课》</li>
<li>《清醒地活》</li>
<li>《沉思录》</li>
<li>《软件体的生命周期》</li>
</ul>
</li>
</ul>
]]></content><link href="https://github.com/goohugo/myblog/issues/20"/><category term="Life"/><published>2023-04-30T07:36:23+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/19</id><title>[笔记]皮囊 </title><updated>2025-01-03T08:43:45.947646+00:00</updated><content type="html"><![CDATA[<h1>皮囊</h1>
<blockquote>
<p>作者：蔡崇达；数量：6个笔记；时间：2023-04-20 11:23:07</p>
</blockquote>
<h2>序：认心、认人的《皮囊》</h2>
<ul>
<li>这也就是为什么，灵魂——中国人把它叫做心，永远贪恋着这个皮囊。又恐琼楼玉宇，高处不胜寒</li>
</ul>
<h2>皮囊</h2>
<ul>
<li>
<p>如果你整天伺候你这个皮囊，不会有出息的，只有会用肉体的人才能成材。</p>
</li>
<li>
<p>黑狗达不准哭。死不就是脚一蹬的事情嘛，要是诚心想念我，我自然会去看你。因为从此之后，我已经没有皮囊这个包袱。来去多方便。</p>
</li>
<li>
<p>那一刻才明白阿太曾经对我说过的一句话，才明白阿太的生活观：我们的生命本来多轻盈，都是被这肉体和各种欲望的污浊给拖住。阿太，我记住了。“肉体是拿来用的，不是拿来伺候的。”请一定来看望我。</p>
</li>
</ul>
<h2>重症病房里的圣诞节</h2>
<ul>
<li>
<p>医院一楼是门诊大厅和停尸房。可以随意打发的疾病，和已经被疾病废弃的身体，比邻而居。生和死同时在这层盛放。
2023年4月28日我们始终要回答的问题</p>
</li>
<li>
<p>我疯狂工作，不让自己有空余时间，除了真实的生存压力，还在于，我根本不敢让自己有空余的时间，因为时间一空下来，我就要回答怎么去填充时间，怎么去面对生活，去回答这个问题——我要怎么生活，我真正喜欢的是什么，我真正享受什么？</p>
</li>
</ul>
<h2>回家</h2>
<ul>
<li>在我生活的这个小镇，所有人都笃信举头三尺有神明，也相信有魂灵，人与鬼神亲近地生活着。我们还相信，魂灵有着和现世一样的属性，会饿到，也会吃太饱，会太胖，然后也会心情不好也会闷出病……</li>
</ul>
]]></content><link href="https://github.com/goohugo/myblog/issues/19"/><category term="Life"/><published>2023-04-30T07:22:29+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/18</id><title>运用.NET框架下的SerialPort类，解决电商包裹称重问题</title><updated>2025-01-03T08:43:46.330933+00:00</updated><content type="html"><![CDATA[<p>当前，几乎所有的电商综合管理系统已将包裹称重环节纳入核心流程，尤其在食品电商领域，其系统内集成的包裹称重功能模块扮演着关键角色，有效防止因包裹重量信息误差而导致的发货差错，并能迅速识别异常包裹，有力地减少了包裹误发的现象。</p>
<p>在食品电商应用的ERP系统中，包裹称重步骤通常嵌入在订单履行流程之中。鉴于顾客下单的商品种类多样、规格各异，采用精确的电子秤进行逐一称重，确保每个商品的实际净重无误，从而杜绝了拣货失误的问题。倘若包裹称重环节设计欠佳，则可能导致一系列错发、漏发事件，进而对整体售后服务品质造成负面影响。</p>
<p>在构建包裹称重体系时，每一个商品均需经过严格的重量测定，商品属性应明确包含净重和总重两项指标。其中，净重是指单一商品本身的标准重量，例如一款40克装的巴西松子其净重为0.04千克；而总重则涵盖了商品及其外包装材料的整体重量，一般情况下会略高于净重。此外，包裹所用的纸箱同样需要逐一称重并记录在案，不同的纸箱规格及其对应重量应在系统产品数据库中预先设定。</p>
<p>包裹重量核验阶段，系统自动执行计算公式：包裹总重 = 纸箱重量 + 商品重量，并要求实际称重数值落在允许的合理偏差范围内。考虑到部分散装商品可能会因自然溢出等因素稍有超出标定重量，这个误差范围通常会被设计得具有一定包容性。</p>
<img src="https://user-images.githubusercontent.com/124132611/235339810-5c115000-a908-4c99-9187-d05489be9edd.png" width="300" height="400" />
<p>在包裹称重界面的精心设计中，涵盖了多项关键数据元素，诸如操作员信息、物流单号、外包装箱条形码、实时包裹重量、重量偏差值、预设标准重量以及包含外包装在内的总体重量等。当用户启动称重界面并把包裹置于电子秤台上时，包裹的实际重量将即刻动态显示于界面上，并且鼠标焦点会智能转移至物流单号的录入区域，待用户输入完成后，系统会自动引导至外箱条码的录入环节。一旦实际的外箱条码数据得到确认，系统会自动运算得出差重数值、匹配的标准重量及包含外包装在内的总重数据。对于已完成称重核实的包裹，系统会流畅地执行称重过程并同步播放一声清脆的完成提示音，以此标志称重作业的顺利结束。反之，针对未能通过系统验证的包裹，系统也会发出特定的警示音以示提醒。在整个流程中，只要差重控制在预设的可接受阈值内，称重操作即可顺遂进行。而若出现较大差重现象，则很可能意味着在拣货环节存在潜在问题，需要进一步核查修正。</p>
<h3>使用SerialPort实现读取COM口获取包裹重量</h3>
<h4>开始称重主方法代码</h4>
<pre><code>private void beginWeight()
{
            try
            {
                timer1.Enabled = false;
                serialPort1.Close(); //关闭COM口
                GetSetComb();//设置Com口

                interfaceUpdataHandle = new HandleInterfaceUpdataDelegate(UpdateTextBox);//实例化委托对象 
                serialPort1.DataReceived += new SerialDataReceivedEventHandler(serialPort1_DataReceived); //接收COM口数据
                if (!serialPort1.IsOpen)
                {
                    serialPort1.Open();
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
                return;
            }
            timer1.Enabled = true;
}
</code></pre>
<h4>设置COM口主要参数</h4>
<pre><code> private void GetSetComb()
 {
            try
            {
                serialPort1.PortName = GlobalSettings.Instance.DefaultCom;
                serialPort1.BaudRate = GlobalSettings.Instance.DefaultBaudRate;
                serialPort1.Parity = (Parity)Enum.Parse(typeof(Parity), &quot;None&quot;);
                serialPort1.StopBits = (StopBits)Enum.Parse(typeof(StopBits), &quot;1&quot;);
                serialPort1.DataBits = 8;
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
            }
}
</code></pre>
<h4>DataReceived 和在TextBox实时显示重量的方法</h4>
<pre><code>private void serialPort1_DataReceived(object sender, SerialDataReceivedEventArgs e)
{
            int i = serialPort1.BytesToRead;
            if (i &gt; 0)
            {
                string strTemp = serialPort1.ReadLine();
                this.Invoke(interfaceUpdataHandle, strTemp);
            }
        }

        private void UpdateTextBox(string text)
        {
            string[] zl = null;
            if (text.Length &gt; 0)
            {
                zl=text.Split(&#x27;,&#x27;);
                if(zl.Length&gt;=2)
                {
                    txtbgzl.Text = zl[2].Replace(&quot;+&quot;,&quot;&quot;).Replace(&quot;kg&quot;,&quot;&quot;).Trim();
                }
            }            
}
</code></pre>
]]></content><link href="https://github.com/goohugo/myblog/issues/18"/><category term="Development"/><published>2023-04-30T06:45:32+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/17</id><title>Github访问速度慢的解决方案</title><updated>2025-01-03T08:43:46.679645+00:00</updated><content type="html"><![CDATA[<p>作为国内的用户，我相信绝大多数的家人们都遇到过一个问题，那就是访问github的时候非常非常慢。甚至有的时候访问网站页面直接死掉。这个时候该有人说了，我有梯子我不怕，上网速度嗖嗖的。</p>
<p>但是如果我们不使用梯子的情况下该怎么办呢？毕竟使用github也是我们的日常。</p>
<h1>Github打开慢的原因：</h1>
<pre><code>  GitHub的CDN(Content Delivery Network,即内容分发网络)域名遭到DNS污染，无法连接使用GitHub的加速分发服务器，
  所以国内访问速度较慢。 

  DNS解析的问题；服务器在国外。
</code></pre>
<h1>方案一：</h1>
<p>方案一：修改本地host文件
修改本地host文件，增加配置内容，绕过域名解析，达到加速的目的。</p>
<h2>获取方式1:</h2>
<p>github.global.ssl.fastly.net.ipaddress.com/#ipinfo 访问这个网址。会得到CDN和IP地址，对应github.com</p>
<p>github.com.ipaddress.com/#ipinfo 访问这个网址，会得到CDN和IP地址，对应github.global.ssl.fastly.net。然后再host中添加配置：</p>
<pre><code>140.82.114.4 github.com
199.232.69.194 github.global.ssl.fastly.net
</code></pre>
<h2>获取方式2:</h2>
<p>访问链接：<a href="https://raw.hellogithub.com/hosts%EF%BC%88ps%EF%BC%9A%E8%BF%99%E9%93%BE%E6%8E%A5%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84host%E9%85%8D%E7%BD%AE%E3%80%82">https://raw.hellogithub.com/hosts（ps：这链接定时更新），获取对应的host配置。</a></p>
<p>如果需要工具自动更新的话，点击链接：<a href="https://github.com/oldj/SwitchHosts">https://github.com/oldj/SwitchHosts</a></p>
<p>特别说明</p>
<p>Github的IP地址是不断变化的，如果发现网站打不开了，可以获取新的IP地址修改hosts里面的内容，方式如下：</p>
<p>在网站https://www.ipaddress.com/ 输入你要解析的域名。例如：github.com的IP获取方式，在输入框输入以下内容：</p>
<p><img src="https://user-images.githubusercontent.com/124132611/235336020-8fde6d5e-6e72-4628-bf19-cf61573a4deb.png" alt="ipaddress.com/" /></p>
<p>敲击你最爱的回车键，你会得到：</p>
<p><img src="https://user-images.githubusercontent.com/124132611/235336030-b969a911-bb42-44a4-bf99-93312430bd28.png" alt="ip" /></p>
<p>要的就是红框框里的内容。获取了相关信息后，可以替换hosts里的内容即可。</p>
<h2>修改HOSTS文件的方法：</h2>
<h3>1、Mac OS系统</h3>
<p>1）、直接打开终端</p>
<p>2）、输入：sudo vim /etc/hosts</p>
<p>3）、输入本机的开机密码</p>
<h3>2、Windows系统</h3>
<p>1）、打开c盘，按照这个路径C:\Windows\System32\drivers\etc\hosts找到hosts文件</p>
<p>2）、用文本编辑器打开文件</p>
<h1>方案二：Github镜像或加速网站</h1>
<p>通过GitHub 镜像访问。这里提供几个最常用的镜像地址：</p>
<pre><code>https://hub.fastgit.xyz/ 
https://gitclone.com/ （此镜像是直接搜索相关仓库，然后克隆）
https://ghproxy.com/ （GitHub 文件 , Releases , archive , gist , raw.githubusercontent.com 文件代理加速下载服务）
https://toolwa.com/github/ （GitHub 加速下载）
</code></pre>
<p>也就是说上面的镜像就是一个克隆版的 GitHub，你可以访问上面的镜像网站，网站的内容跟 GitHub 是完整同步的镜像，然后在这个网站里面进行下载克隆等操作。</p>
<p>注意是否已失效，当然也可搜索其他的镜像网址或加速网站。</p>
]]></content><link href="https://github.com/goohugo/myblog/issues/17"/><category term="Technical Articles"/><published>2023-04-30T04:48:33+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/16</id><title>SQL2012的新分页方法</title><updated>2025-01-03T08:43:47.060830+00:00</updated><content type="html"><![CDATA[<pre><code>DECLARE @PageNumber INT = 6
DECLARE @RowsCountPerPage INT = 10

SELECT  BusinessEntityID ,
        FirstName ,
        LastName
FROM    Person.Person
ORDER BY BusinessEntityID
        OFFSET ( @PageNumber - 1 ) * @RowsCountPerPage ROWS
 FETCH NEXT @RowsCountPerPage ROWS ONLY

</code></pre>
]]></content><link href="https://github.com/goohugo/myblog/issues/16"/><category term="Technical Articles"/><published>2023-04-29T09:19:51+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/14</id><title>有哪些很重要又被忽视的炒菜技巧</title><updated>2025-01-03T08:43:47.428293+00:00</updated><content type="html"><![CDATA[<p>1.肉类焯水要用冷水入锅，热水下锅外面的肉直接熟了，血水锁在里面出不来。</p>
<p>2.煮鸡蛋要在水还没开的时候下锅，以免蛋白质受到水流冲击变散，包裹空气变成浮沫。</p>
<p>3.煮挂面要在水里起小气泡的时候下锅，盖上锅盖，水开就往里面点凉水。水再次开的时候，面差不多就熟了。</p>
<p>4.鲜的手擀面，要在水开的时候下锅，搅动的时候必须往一个方向，避免黏连。火开到最大，小火面条容易糊化。点两次凉水。</p>
<p>5.煮面放醋，醋会让面条口感更好，煮出来更白，减少面的碱性。</p>
<p>6.煮饺子，如果是速冻饺子要冷水下锅，借着水温慢慢化冻；刚包好的饺子要热水下锅。</p>
<p>7.水开就点凉水，不能一直沸腾，不然皮熟透烂了，里面的肉还是没熟。差不多点三次凉水正好。</p>
<p>8.钟水饺的灵魂在于咸味和甜味的融合，还有红油带来的辣味和视觉冲击。最简单的方法是酱油加糖加红油，最好是用葱姜蒜炼一次酱油，然后加冰糖，小火融化，让咸味和甜味更好的融合。</p>
<p>9.阳春面的灵魂在于猪油的香味和鸡汤的鲜味。碗底生抽猪油小葱，生抽味道足够了，可以不加盐。没有鸡汤的时候，汤底可以加鸡精。面用细挂面最好。</p>
<p>10.泡发腐竹最好用冷水，泡上两三个小时。热水快速泡发容易破，口感也没那么劲道。</p>
<p>11.红油+凉拌汁+蒸鱼豉油+醋+糖，可以凉拌一切。特别适合腐竹、木耳、千张、豆腐丝、鸡丝、杏鲍菇、金针菇这些。（附：蒸鱼豉油是在生抽基础上处理了一下，味道更鲜，着色更弱。适合凉拌和蒸鱼。）</p>
<p>12.麻辣鸡丝的鸡丝，冷水下锅后，煮开，然后小火继续煮个七八分钟，让鸡肉完全熟。（鸡胸肉比较干，脂肪少；鸡腿肉香一些，脂肪更多）</p>
<p>13.焯水要去腥味，加料酒，姜片，葱白。</p>
<p>14.凉拌鸡丝的时候可以加一点坚果进去，最常见的就是花生，拍成花生碎，炒香，加进去。</p>
<p>15.自己做油泼辣子：辣椒碎，花椒，白芝麻，热油一浇即成。</p>
<p>16.糖可以减少咸味和酸味，突出鲜味。</p>
<p>17.红烧鱼要在油微热的时候加一点糖，油变成金黄色再把鱼放进去煎，这样鱼皮不容易破。</p>
<p>18.肉下锅之前先用淀粉抓一遍，不然很容易老。肉比菜难入味，要提前用生抽腌制一下。起锅的时候加一点醋，能让肉变得更嫩更香。</p>
<p>19.横切牛羊竖切猪，斜切鸡。</p>
<p>20.蛋白质含量高的汤都可以加牛奶提鲜，比如鱼汤和鸡汤。煮泡面、韩式年糕火锅、麻辣烫都可以用牛奶来增鲜，也可以让汤底的口感更浓稠。</p>
<p>21.料酒下锅可以沿着锅边淋入，高温能够快速蒸发料酒，炝锅。酱油要淋在菜上，高温容易让酱油糊了。</p>
<p>22.炒粉丝要先把粉丝给焯水。焯水后要加醋浸泡5分钟，这样粉丝才不会太软而且黏连；炒粉丝不能点水，水会让粉丝的淀粉流出，锅太干了只能加油；用锅铲的反面推动菜，避免把粉丝炒碎，卖相太差。</p>
<p>23.清蒸鲈鱼，猛火七八分钟，虚火（关火之后）焖3分钟，肉质细嫩。蒸鱼的时候要在水开之后在把鱼放进去，高温会让表面收缩，肉更紧实更鲜嫩，色泽也更好看。</p>
<p>24.炒蔬菜的时候，加水要加热水，更脆嫩。加冷水会让菜变硬。炒肉的时候，肉遇热后又遇冷，里面难熟，不能加冷水。如果肉已经炒熟了，加冷水可以让肉的口感Q弹一点。</p>
<p>25.蒸鸡蛋羹时用温开水搅，这样蒸出来的蛋羹比用冷水调的蛋羹更加鲜嫩。煎鸡蛋时，洒几滴热水在蛋周围和面上，可使蛋黄完整，表面更光滑。这样煎出来的鸡蛋表面凝固了，但是里面还是溏心的。</p>
<p>26.炒鸡蛋时，一个蛋加一汤匙温水搅匀，就不会炒“老”，且炒出的蛋量多，松软可口。</p>
<p>27.煮鸡蛋时，先将蛋放在冷水里浸湿，再放进热水里煮，蛋壳便不会破裂并且容易剥皮。</p>
<p>28.煮饭用开水，可以缩短蒸煮时间，保护米中的维生素，减少营养损失。煮饭的时间越长，维生素B1损失的越快。</p>
<p>29.炒方便面的面只能8分熟，不要全熟。水开之后下面，到面饼能打散，立刻捞出来，过凉水。炒方便面的调料加一点豆瓣酱更好吃，也可以用辣椒酱。加生抽老抽蚝油和糖。</p>
<p>30.汤里面打蛋花，要在锅开了之后，关火打入蛋花。</p>
<p>31.起锅的时候再加盐和醋，过早加盐，蔬菜里的水分析出来，口感黏软；醋易挥发，先加的话会破坏色泽和口感。</p>
]]></content><link href="https://github.com/goohugo/myblog/issues/14"/><category term="Life"/><published>2023-03-20T01:01:19+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/13</id><title>解决Win10电脑无法登录微软账号的方法</title><updated>2025-01-03T08:43:47.795737+00:00</updated><content type="html"><![CDATA[<p>设置IP地址的dns为：首选DNS 服务器 4.2.2.2   备用DNS 服务器 4.2.2.1
<a href="https://zhuanlan.zhihu.com/p/365217700">具体操作步骤参考</a></p>
]]></content><link href="https://github.com/goohugo/myblog/issues/13"/><category term="Technical Articles"/><published>2023-03-05T03:20:15+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/12</id><title>省市区地址解析</title><updated>2025-01-03T08:43:48.162921+00:00</updated><content type="html"><![CDATA[<pre><code>public string Analysis(string address)
{  
            string regex = @&quot;(?&lt;province&gt;[^省]+自治区|.*?省)?(?&lt;city&gt;[^市]+自治州|.*?地区|.*?行政单位|.+盟|市辖区|.*?市)?(?&lt;county&gt;[^县]+县|[^区]+区|[^市]+市|.+旗|.+海域|.+岛)?(?&lt;town&gt;[^区]+区|.+镇|.+办事处)?(?&lt;village&gt;.*)&quot;;
            var m = Regex.Match(addr, regex, RegexOptions.IgnoreCase);
            var province = m.Groups[&quot;province&quot;].Value;//省
            var city = m.Groups[&quot;city&quot;].Value;//市
            var county = m.Groups[&quot;county&quot;].Value;//县
            var town = m.Groups[&quot;town&quot;].Value;//镇
            var village = m.Groups[&quot;village&quot;].Value;//详细地址
}
</code></pre>
]]></content><link href="https://github.com/goohugo/myblog/issues/12"/><category term="Development"/><published>2023-02-13T05:05:40+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/10</id><title>git中的SSL证书问题：无法获取本地颁发者证书错误的解决办法</title><updated>2025-01-03T08:43:48.520524+00:00</updated><content type="html"><![CDATA[<p>我们在使用git初始化一个项目时，尤其是通过git submodule update --init --remote初始化子模块时，可能会遇到下面这个错误：
fatal: unable to access 'https://myserver.com/gogs/user1/myapp/': SSL certificate problem: unable to get local issuer certificate</p>
<p>这是由于当你通过HTTPS访问Git远程仓库的时候，如果服务器上的SSL证书未经过第三方机构认证，git就会报错。原因是因为未知的没有签署过的证书意味着可能存在很大的风险。解决办法就是通过下面的命令将git中的sslverify关掉：</p>
<pre><code>git config --global http.sslverify false
</code></pre>
<p>上面这行命令的影响范围是系统当前用户，如果要设置为全局所有用户，可以改成这样：</p>
<pre><code>git config --system http.sslverify false
</code></pre>
<p>如果只是想针对当前仓库进行设置，可以在需要修改的仓库目录下执行：</p>
<pre><code>git config http.sslverify false
</code></pre>
<p>如果你的仓库中存在嵌套的git子模块（就是子模块中又引用了子模块），在进行初始化时，仍然有可能遇到self signed certificate in certificate chain的错误，此时可以通过执行下面的命令来解决：</p>
<pre><code>npm config set strict-ssl false
</code></pre>
<p>对于npm而言，除了可以在package.json的scripts属性中自定义脚本外，npm-scripts也内置了一些脚本，用来在特定的时机执行某些特定的任务，具体可以参照npm的官方文档https://docs.npmjs.com/misc/scripts</p>
]]></content><link href="https://github.com/goohugo/myblog/issues/10"/><category term="Technical Articles"/><published>2023-02-07T01:13:10+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/9</id><title>Scoop windows下的包管理器</title><updated>2025-01-03T08:43:48.882887+00:00</updated><content type="html"><![CDATA[<h1>Scoop 安装</h1>
<h2>环境需求</h2>
<ul>
<li>PowerShell 5 +</li>
<li>.NET Framework 4.5 +
<img src="https://user-images.githubusercontent.com/124132611/216545926-1d034692-d7ae-491a-9237-04065711e7e6.jpg" alt="scoop-01" /></li>
</ul>
<h1>安装</h1>
<h2>指定安装位置（配置环境变量）</h2>
<p>以管理员身份打开PowerShell</p>
<pre><code class="language-yml">$env:SCOOP=&#x27;D:\Applications\Scoop&#x27;
[Environment]::SetEnvironmentVariable(&#x27;SCOOP&#x27;, $env:SCOOP, &#x27;User&#x27;)
$env:SCOOP_GLOBAL=&#x27;F:\GlobalScoopApps&#x27;
[Environment]::SetEnvironmentVariable(&#x27;SCOOP_GLOBAL&#x27;, $env:SCOOP_GLOBAL, &#x27;Machine&#x27;)
</code></pre>
<h1>安装Scoop</h1>
<p>首先确保你能访问 raw.githubusercontent.com</p>
<pre><code class="language-yml">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&#x27;https://get.scoop.sh&#x27;)
# 或者
iwr -useb get.scoop.sh | iex
irm https://cdn.jsdelivr.net/gh/duzyn/scoop-cn/install.ps1 | iex
irm https://ghproxy.com/raw.githubusercontent.com/duzyn/scoop-cn/master/install.ps1 | iex
</code></pre>
<h1>Scoop 使用</h1>
<h2>Scoop官方维护的仓库</h2>
<ul>
<li>main - 默认仓库</li>
<li>extras - 默认仓库的补充超级强大</li>
<li>games - 看名字就知道啦</li>
<li>nerd-fonts - Nerd Fonts</li>
<li>nirsoft - A subset of the 250 Nirsoft apps</li>
<li>java - Installers for Oracle Java, OpenJDK, Zulu, ojdkbuild, AdoptOpenJDK, Amazon Corretto, BellSoft Liberica &amp; SapMachine</li>
<li>jetbrains - Installers for all JetBrains utilities and IDEs</li>
<li>nonportable - Non-portable apps (may require UAC)</li>
<li>php - Installers for most versions of PHP</li>
<li>versions - Alternative versions of apps found in other buckets</li>
</ul>
<p>可以直接通过scoop bucket add &lt;repo_name&gt;安装</p>
<p>由于某些原因，每次更新仓库的时间奇慢，所以还是换为国内镜像仓库来增加使用体验</p>
<h1>镜像仓库</h1>
<ul>
<li>
<p><a href="https://mirror.nju.edu.cn/git/scoop-main.git">main</a></p>
</li>
<li>
<p><a href="https://mirror.nju.edu.cn/git/scoop-extras.git">extras</a></p>
</li>
<li>
<p><a href="https://gitee.com/scoop-bucket/dorado.git">dorado</a></p>
</li>
</ul>
<h1>执行以下命令安装必装软件</h1>
<pre><code class="language-yml">scoop install aria2 git 7zip
</code></pre>
<p>反正你肯定要用到！
或者</p>
<pre><code>scoop install https://ghproxy.com/raw.githubusercontent.com/duzyn/scoop-cn/master/bucket/7zip.json
scoop install https://ghproxy.com/raw.githubusercontent.com/duzyn/scoop-cn/master/bucket/git.json
scoop install https://ghproxy.com/raw.githubusercontent.com/duzyn/scoop-cn/master/bucket/aria2.json
</code></pre>
<p>或者</p>
<pre><code>scoop install https://cdn.jsdelivr.net/gh/duzyn/scoop-cn/bucket/7zip.json
scoop install https://cdn.jsdelivr.net/gh/duzyn/scoop-cn/bucket/git.json
scoop install https://cdn.jsdelivr.net/gh/duzyn/scoop-cn/bucket/aria2.json
</code></pre>
<h1>对aria2进行设置</h1>
<pre><code>scoop config aria2-split 3 
scoop config aria2-max-connection-per-server 3 
scoop config aria2-min-split-size 1M
</code></pre>
<h1>对scoop_repo进行更改</h1>
<pre><code>scoop config SCOOP_REPO https://gitee.com/scoop-bucket/scoop
</code></pre>
<h1>执行以下命令订阅软件仓库</h1>
<pre><code>scoop bucket rm main
scoop bucket add main https://mirror.nju.edu.cn/git/scoop-main.git
scoop bucket add extras https://mirror.nju.edu.cn/git/scoop-extras.git
</code></pre>
<p>以上两个是官方bucket的国内镜像，所有软件建议优先从这里下载。</p>
<pre><code>scoop bucket add dorado https://gitee.com/scoop-bucket/dorado.git
</code></pre>
<h1>使用Scoop安装常用软件</h1>
<pre><code>scoop install 7zip aria2 python vscode typora vlc sumatrapdf
</code></pre>
<h1>每次添加完仓库记得更新一下！</h1>
<pre><code>scoop update
</code></pre>
<h1>另外附上常用命令</h1>
<pre><code>scoop update  #更新仓库
scoop update *  #更新所有软件
scoop list  #列出已安装的软件
scoop bucket list  #列出已订阅的仓库
</code></pre>
]]></content><link href="https://github.com/goohugo/myblog/issues/9"/><category term="Technical Articles"/><published>2023-02-03T08:20:51+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/6</id><title>奇趣网站</title><updated>2025-01-03T08:43:49.246230+00:00</updated><content type="html"><![CDATA[<ul>
<li>收藏有趣的网站</li>
</ul>
]]></content><link href="https://github.com/goohugo/myblog/issues/6"/><category term="Friends"/><published>2023-02-02T07:53:36+00:00</published></entry><entry><id>https://github.com/goohugo/myblog/issues/1</id><title>WeeklyReport 2022</title><updated>2025-01-03T08:43:49.617095+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>人生不是一种享乐，而是一桩十分沉重的工作。</p>
</blockquote>
<ul>
<li>
<strong>D52</strong><ul>
<li>仓库 订货单新增右键菜单标记已导入</li>
<li>组装礼盒</li>
</ul>
</li>
<li>
<strong>D51</strong><ul>
<li>生产 - 解决产品结构图汇总统计查询缓慢问题</li>
<li>电商 - 抖音小店当卖家添加备注消息推送后，会同步到ERP订单的卖家备注中</li>
<li>电商 - 抖音小店当买家发起售后申请，接到推送消息后，会同步标记订单到待处理</li>
<li>电商 - 修复超重拆单订单未正确标记问题</li>
<li>电商 - 订单扫描新增检测被合并订单退款状态, 若状态为待处理状态，则终止扫描</li>
<li>电商 - 提醒客服抖音小店有客户修改发货地址</li>
</ul>
</li>
<li>
<strong>D50</strong><ul>
<li>电商 - 会员统计分析新增回购率统计</li>
<li>直播 - 抖音小店消息推送服务调试</li>
</ul>
</li>
<li>
<strong>D49</strong><ul>
<li>生产 - 要货申请、派工排产、包装入库新增钉钉消息发送到负责人功能；</li>
<li>电商 - 官方商城心意卡兑换订单发货时，提供物流短信提醒功能</li>
<li>电商 - 备货计划单功能优化</li>
</ul>
</li>
<li>
<strong>D48</strong><ul>
<li>电商 - 修复退款订单解锁后，无法订单审核里查询不到问题</li>
<li>电商 - 按店铺导出订单商品、支付金额、客户地址等信息方便对账</li>
<li>电商 - 要货计划单优化</li>
</ul>
</li>
<li>
<strong>D47</strong><ul>
<li>系统 - 登录时验证IP，外网登录需绑定机器码；</li>
<li>电商 - 会员管理功能优化</li>
<li>电商 - 顺丰和极兔快递物流单扫描称重优化</li>
<li>电商 - 协助电商计算直播平台物流费用</li>
<li>电商 - 备货计划单生成代码编写</li>
</ul>
</li>
<li>
<strong>D46</strong><ul>
<li>仓库 - 调拨单据新增单据说明和是否大单团购选项</li>
<li>电商 - 订单查询新增达人ID筛选</li>
<li>电商 - 修复天猫旗舰店会员ID重复问题</li>
<li>电商 - 新增订单收货地址解析优化</li>
<li>电商 - 订单审核复制订单优化</li>
</ul>
</li>
<li>
<strong>D45</strong><ul>
<li>电商- 订单新增地址解析功能</li>
<li>电商 - 后台服务新增错误钉钉提醒功能</li>
<li>电商 - 解决 合并订单退款时，无法扫描称重问题</li>
<li>电商 - 订单打印新增保存单号失败提醒功能</li>
<li>电商 - 订单打印增加预打包订单统计功能 </li>
</ul>
</li>
<li>
<strong>D44</strong><ul>
<li>电商-历史订单补打问题修复；新增分包物流单号补打；订单审核异常处理；</li>
<li>加盟商系统 - 单据入库确认问题修改</li>
<li>生产 - 产品结构图包装物出库价格取值问题修改</li>
</ul>
</li>
<li>
<strong>D43</strong><ul>
<li>电商-电子面单打印整合上线运行，已修复问题，目前运行良好；</li>
<li>电商-订单查询功能优化，支持通过来源单号查询被合并订单；</li>
<li>电商-订单审核功能优化，取物流单号失败的订单，无法审核，减少反审核次数。</li>
</ul>
</li>
</ul>
]]></content><link href="https://github.com/goohugo/myblog/issues/1"/><category term="Life"/><published>2023-02-01T07:49:29+00:00</published></entry></feed>